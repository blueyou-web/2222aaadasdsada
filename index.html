<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인터랙티브 게임 보드 (Firebase 연동)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto-Sans-KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1c1c1b;
            --bg-secondary: #1c1c1b;
            --bg-tertiary: #374151;
            --bg-board: rgaba(36, 36, 36, 0.5);
            --border-primary: #D4B783;
            --border-secondary: #4b5563;
            --text-primary: #EAEAEA;
            --text-secondary: #B0B0C0;
            --text-tertiary: #888899;
            --accent-primary: #D4B783;
            --accent-secondary: #C1A26C;
            --modal-backdrop: rgba(0, 0, 0, 0.8);
            --log-move: #60A5FA;
            --log-damage: #F87171;
            --log-heal: #4ADE80; 
            --log-system: #FBBF24;
            --log-join: #4ADE80;
            --log-admin: #9333ea;
            --turn-highlight-color: #caa954;
            --bg-game-id: #1f2937;
            --bg-selection-overlay: linear-gradient(180deg, var(--bg-primary) 0%, rgba(36, 36, 36, 0.7) 100%);
            --mp-color: #3B82F6;
            
            /* Custom Scrollbar Colors (Dark Mode) */
            --scrollbar-thumb: var(--accent-primary);
            --scrollbar-track: #2d2d2d;

            /* Skill Button Glow/Ring Color */
            --skill-ring-color: rgba(212, 183, 131, 0.8);

            /* Turn Box Style */
            --turn-box-bg: rgba(55, 65, 81, 0.5); /* Semi-transparent tertiary bg */
            --turn-box-border: var(--accent-primary);
            --summary-box-bg: rgba(212, 183, 131, 0.1);

            /* NEW: Gradients for numbers */
            --gradient-start: #ffffff; 
            --gradient-end: var(--accent-primary);
            --pc-color: #4ADE80;
            --enemy-color: #F87171;
        }

        html.light {
            --bg-primary: #FDFBF6;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #E5E7EB;
            --bg-board: rgba(229, 231, 235, 0.8);
            --border-primary: #8C6A48;
            --border-secondary: #D1D5DB;
            --text-primary: #3A3226;
            --text-secondary: #574B3A;
            --text-tertiary: #6B7280;
            --accent-primary: #8C6A48;
            --accent-secondary: #A98A66;
            --turn-highlight-color: #D97706;
            --log-admin: #6D28D9;
            --bg-game-id: #E5E7EB;
            --bg-selection-overlay: linear-gradient(180deg, var(--bg-primary) 0%, rgba(229, 231, 235, 0.7) 100%);
            --mp-color: #1D4ED8;

            /* Custom Scrollbar Colors (Light Mode) */
            --scrollbar-thumb: var(--accent-primary);
            --scrollbar-track: #F0F0F0;

            /* Skill Button Glow/Ring Color */
            --skill-ring-color: rgba(140, 106, 72, 0.8);

            /* Turn Box Style */
            --turn-box-bg: rgba(229, 231, 235, 0.5); /* Semi-transparent tertiary bg */
            --turn-box-border: var(--accent-primary);
            --summary-box-bg: rgba(140, 106, 72, 0.1);

            /* NEW: Gradients for numbers (Light Mode adjustment) */
            --gradient-start: #3A3226; 
            --gradient-end: #000000;
            --pc-color: #16A34A;
            --enemy-color: #DC2626;
        }

        /* Global Custom Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px; /* For horizontal scrollbars */
        }
        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 10px;
            opacity: 0.7; /* Make slightly translucent */
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }
        
        /* Custom horizontal scrollbar for selection list (more transparent) */
        #selection-list::-webkit-scrollbar {
            height: 6px;
        }
        #selection-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        html.light #selection-list::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            background-image: var(--page-background-image); /* JS에서 제어할 변수 */
            background-size: cover; /* 화면 전체를 덮도록 설정 */
            background-position: center; /* 이미지를 중앙에 위치 */
            background-repeat: no-repeat; /* 이미지가 반복되지 않도록 설정 */
            background-attachment: fixed; /* 스크롤해도 배경은 고정 */
        }
        
        body, h1, h2, h3, h4, button, .font-title {
            font-family: 'Cinzel', 'Noto Sans KR', serif;
            letter-spacing: 0.5px;
        }
        
        body {
            padding-top: 250px; 
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(10, minmax(0, 1fr));
            grid-template-rows: repeat(10, minmax(0, 1fr));
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 90vw;
            max-height: 90vh;
            background-color: var(--bg-board);
            border: 1px solid var(--border-secondary);
            /* NEW: Background image style */
            background-size: cover;
            background-position: center;
        }
        .cell {
            border: 1px solid var(--border-secondary);
            position: relative;
            transition: background-color 0.2s;
        }

        .cell:hover {
            background-color: rgba(212, 183, 131, 0.1);
        }
        
        /* NEW: Obstacle and Damage Tiles Styles */
        .cell.tile-obstacle {
            background-color: #4B5563; /* Dark gray */
            background-image: repeating-linear-gradient(45deg, rgba(0,0,0,.1) 0, rgba(0,0,0,.1) 2px, transparent 0, transparent 5px);
            cursor: not-allowed;
        }
        .cell.tile-damage {
            background-color: #991B1B; /* Dark red */
            box-shadow: inset 0 0 10px rgba(248, 100, 100, 0.5);
            cursor: help;
        }
        .cell.tile-damage:hover {
            background-color: #EF4444;
        }

        .combat-range {
            outline: 2px solid transparent;
            outline-offset: -2px;
            transition: outline 0.2s, background-color 0.2s, box-shadow 0.2s;
            box-shadow: inset 0 0 12px;
        }

        .attack-range-move {
            background-color: rgba(212, 183, 131, 0.05);
            outline-color: var(--accent-primary);
            box-shadow: inset 0 0 12px var(--accent-primary);
        }

        .attack-range-skill {
            background-color: rgba(239, 68, 68, 0.05);
            outline-color: var(--log-damage);
            box-shadow: inset 0 0 12px var(--log-damage);
        }
        
        .heal-range-skill {
            background-color: rgba(74, 222, 128, 0.08);
            outline-color: var(--log-heal);
            box-shadow: inset 0 0 12px var(--log-heal);
        }

        .enemy-threat-range {
            background-color: rgba(200, 50, 50, 0.07);
        }

        @keyframes turn-glow {
            0% { 
                /* 변경: inset 제거 및 box-shadow 값 수정 */
                box-shadow: 0 0 8px 2px var(--turn-highlight-color); 
            }
            50% { 
                /* 변경: inset 제거 및 box-shadow 값 수정 */
                box-shadow: 0 0 16px 5px var(--turn-highlight-color); 
            }
            100% { 
                /* 변경: inset 제거 및 box-shadow 값 수정 */
                box-shadow: 0 0 8px 2px var(--turn-highlight-color); 
            }
        }

        .character-token {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s, filter 0.3s;
            position: absolute; 
            z-index: 20;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
        }

        .character-token.current-turn-glow { /* NEW Class for Token Glow */
            /* 기존 box-shadow와 animation 속성을 제거합니다. */
            /* 이 클래스는 이제 :before 가상 요소를 만들기 위한 식별자로만 사용됩니다. */
            border-color: var(--turn-highlight-color); /* 테두리 색상 강조는 유지할 수 있습니다. */
        }
        /* NEW: Glow effect moved to a pseudo-element to appear behind the token */
        .character-token.current-turn-glow::before {
            content: ''; /* 가상 요소 생성을 위해 필수 */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%; /* 부모 토큰과 똑같은 원형 */
            
            /* z-index를 -1로 주어 토큰 이미지(부모)보다 뒤에 위치시킴 */
            z-index: -1; 
            
            /* 1단계에서 수정한 애니메이션을 여기에 적용 */
            animation: turn-glow 3s infinite ease-in-out;
        }
        .character-token.enemy-token {
            border-color: #ef4444;
        }
          .status-effect-icon {
            position: absolute;
            top: -5px; /* 토큰보다 살짝 위로 */
            right: -5px;
            font-size: 1.5rem; /* 아이콘 크기 */
            z-index: 25; /* 토큰 이미지(20)보다 위에 표시 */
            pointer-events: none; /* 아이콘이 클릭을 방해하지 않도록 설정 */
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 1)); /* 아이콘이 잘 보이도록 그림자 추가 */
        }

        /* Damage Effect */
        .character-token.show-hit-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.4);
            box-shadow: inset 0 0 10px rgba(255, 0, 0, 0.6);
            pointer-events: none;
        }

        @keyframes hit-effect {
            0%, 100% { transform: translate(0, 0) rotate(0); }
            20% { transform: translate(-3px, 0) rotate(-2deg); }
            40% { transform: translate(3px, 0) rotate(2deg); }
            60% { transform: translate(-3px, 0) rotate(-2deg); }
            80% { transform: translate(3px, 0) rotate(2deg); }
            50% { filter: brightness(1.7) drop-shadow(0 0 5px #ef4444); }
        }

        .hit-animation {
            animation: hit-effect 0.5s ease-in-out;
        }
        
        /* Heal Effect */
        .character-token.show-heal-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.4); 
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.6);
            pointer-events: none;
        }

        @keyframes heal-effect {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.5) drop-shadow(0 0 5px #4ADE80); }
        }

        .heal-animation {
            animation: heal-effect 0.5s ease-in-out;
        }

        /* Turn Marker Animation */
        @keyframes bounce-arrow {
            0%, 100% { 
                transform: translateX(-50%) translateY(0); 
            }
            50% { 
                transform: translateX(-50%) translateY(-6px); /* Reduced movement */
            }
        }
        
        .turn-marker {
            /* Position adjusted slightly to the left */
            position: absolute;
            top: -1.5rem; /* Reduced distance */
            left: 50%; /* Moved from 45% for more left shift */
            transform: translateX(-50%);
            color: var(--turn-highlight-color);
            font-size: 1.5rem; /* Reduced size */
            line-height: 1;
            /* Bounce only */
            animation: bounce-arrow 1s infinite ease-in-out; 
            z-index: 30;
            
            /* Outer Glow Styles REMOVED from marker itself */
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.7)); 
            border-radius: 50%;
            padding: 0 4px; 
            background-color: rgba(0,0,0,0.1); 
            cursor: pointer;
        }
        
        .turn-marker:after {
           /* GLOW REMOVED FROM MARKER :after */
           content: none;
        }
        

        /* HP/MP Bar styles */
        .hp-mp-bar-container {
             position: absolute;
             bottom: 0;
             left: 0;
             width: 100%;
             z-index: 5;
             display: flex;
             flex-direction: column;
             gap: 1px; /* Space between bars */
             padding: 1px 0; /* Vertical padding */
        }
        .hp-bar {
            height: 3px;
            background-color: #3b0707;
            overflow: hidden;
            width: 90%;
            margin: 0 auto;
            border-radius: 1px;
        }
        .mp-bar {
            height: 2px; /* Smaller MP bar */
            background-color: #111827;
            overflow: hidden;
            width: 90%;
            margin: 0 auto;
            border-radius: 1px;
        }
        .hp-fill { background-color: #EF4444; height: 100%; transition: width 0.3s; }
        .mp-fill { background-color: var(--mp-color); height: 100%; transition: width 0.3s; }

        html:not(.light) .character-token:not(.enemy-token) {
            box-shadow: 0 0 8px rgba(212, 183, 131, 0.4), 0 0 10px rgba(0,0,0,0.5);
        }
        .token-placeholder {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-primary);
        }
        .character-token:hover {
            transform: scale(1.1);
        }  #game-board.targeting-active .character-token:hover {
            transform: none; /* 크기 변경 효과(scale)를 없앱니다. */
        }
        .selected-character {
             box-shadow: 0 0 15px 3px var(--accent-primary);
             border-color: var(--accent-primary) !important;
        }
        .token-click-through {
            opacity: 0.7; /* [추가] 피드백을 위해 살짝 반투명하게 만듭니다. */
            pointer-events: none; /* 이 요소에 대한 마우스 이벤트를 무시하고, 아래에 있는 요소(셀)가 클릭되도록 합니다. */
        }
        
        .form-input {
             background-color: var(--bg-tertiary);
             border: 1px solid var(--border-secondary);
             color: var(--text-primary);
             border-radius: 4px;
             padding: 0.5rem 0.75rem;
             width: 100%;
             transition: all 0.2s;
        }
        .form-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 5px rgba(212, 183, 131, 0.5);
            outline: none;
            background-color: var(--bg-tertiary);
        }

        .panel {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            position: relative;
            box-shadow: 0 0 15px rgba(0,0,0, 0.2);
            border-image: linear-gradient(to bottom right, var(--accent-secondary), transparent) 1;
        }
        
        .modal-content {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            box-shadow: 0 0 25px rgba(212, 183, 131, 0.2);
        }
        .modal-backdrop {
            background-color: var(--modal-backdrop);
            backdrop-filter: blur(2px);
        }

        #character-selection-overlay {
            height: 250px; 
            background: var(--bg-selection-overlay);
            backdrop-filter: blur(4px);
            z-index: 40;
            border-bottom: 1px solid var(--border-secondary);
            transition: height 0.3s ease-in-out, background-color 0.3s;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
        }
        
        #character-selection-overlay.collapsed { height: 1rem; }
        /* NEW: Improved horizontal scrolling for selection list */
        #selection-list { 
            overflow-x: scroll; 
            white-space: nowrap; 
            -webkit-overflow-scrolling: touch; 
            justify-content: flex-start; /* Align cards to the start for better horizontal flow */
        }
        #selection-list::-webkit-scrollbar {
            height: 6px;
        }
        #selection-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        html.light #selection-list::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }

        .char-card-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 150px; 
            height: 200px; 
            min-width: 150px; 
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            background-size: cover;
            background-position: center top; 
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s;
            border: 1px solid var(--border-secondary);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .card-placeholder { font-size: 4rem; color: var(--accent-primary); opacity: 0.5; }
        .char-card-item:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(212, 183, 131, 0.2); border-color: var(--accent-primary); }
        .char-card-item.selected { border-color: var(--accent-primary); transform: scale(1.05); box-shadow: 0 0 25px var(--accent-primary); }
        .char-card-item:not([draggable="true"]) { cursor: default; }
        .char-card-item[draggable="true"] { cursor: grab; }

        .char-card-item.enemy-card { border-color: #7f1d1d; }
        .char-card-item.enemy-card:hover { border-color: #ef4444; box-shadow: 0 10px 20px rgba(239, 68, 68, 0.2); }
        .char-card-item.enemy-card.selected { border-color: #ef4444; box-shadow: 0 0 25px #ef4444; }

        .char-card-item .char-card-info { background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.0) 60%); }
        html.light .char-card-item .char-card-info { 
             background: linear-gradient(0deg, rgba(200, 200, 200, 0.9) 0%, rgba(255, 255, 255, 0.0) 60%); 
             color: var(--text-primary);
        }
        html.light .char-card-item.enemy-card .char-card-info { 
             background: linear-gradient(0deg, rgba(255, 200, 200, 0.9) 0%, rgba(255, 255, 255, 0.0) 60%);
             color: var(--text-primary);
        }

        .enemy-card .details-btn { border-color: #991b1b; color: #f87171; }
        .enemy-card .details-btn:hover { border-color: #ef4444; color: #ef4444; }


        .char-card-info {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px; 
            height: 100%; 
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            color: var(--text-primary);
        }

        .turn-highlight {
            border: 1px solid #fBBF24;
            background-color: rgba(251, 191, 36, 0.05);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.2);
        }
        
        button { letter-spacing: 1px; border-radius: 2px; transition: all 0.2s ease; border: 1px solid var(--border-secondary); }
        button:hover { border-color: var(--accent-primary); color: var(--accent-primary); background-color: rgba(212, 183, 131, 0.1) !important; box-shadow: 0 0 10px rgba(212, 183, 131, 0.3); }
        button.bg-green-600 { background-color: var(--accent-primary) !important; color: var(--bg-primary) !important; font-weight: bold; border: none; }
        button.bg-red-600 { background-color: var(--log-damage) !important; color: var(--text-primary) !important; font-weight: bold; border: none; }
        
        #admin-panel-btn { background-color: var(--accent-primary); color: var(--bg-primary) !important; }

        .details-btn { background: transparent; border: 1px solid var(--accent-secondary); color: var(--accent-secondary); padding: 2px 8px; font-size: 0.75rem; border-radius: 2px; }

        #game-log-list li { background-color: transparent; padding: 4px 0; border: none; position: relative; padding-left: 1.75rem; line-height: 1.5; font-size: 0.8rem; font-family: 'Noto Sans KR', sans-serif; }
        #game-log-list li::before { content: '•'; position: absolute; left: 0.5rem; top: 4px; font-weight: bold; color: var(--accent-primary); }
        #game-log-list .log-move::before { color: var(--log-move); }
        #game-log-list .log-damage::before { color: var(--log-damage); }
        #game-log-list .log-heal::before { color: var(--log-heal); }
        #game-log-list .log-system::before { color: var(--log-system); }
        #game-log-list .log-join::before { color: var(--log-join); }
        #game-log-list .log-admin-move::before { color: var(--log-admin); }

        .profile-modal-container { 
            background: url('https://www.transparenttextures.com/patterns/dark-matter.png'), linear-gradient(to bottom right, #1a1a1a, #111111); 
            color: var(--text-primary); 
            border: 1px solid var(--accent-primary); 
            box-shadow: 0 0 30px rgba(212, 183, 131, 0.3); 
            display: grid; 
            grid-template-columns: 350px 1fr;
            width: 100%; 
            max-width: 900px; 
            /* height: 600px; Remove fixed height */
            max-height: 90vh; /* Set max height relative to viewport */
            overflow: hidden; 
            position: relative; 
        }
        .profile-modal-container.enemy-profile { border-color: #ef4444; box-shadow: 0 0 30px rgba(239, 68, 68, 0.3); }
        .profile-modal-container.enemy-profile .profile-char-name, 
        .profile-modal-container.enemy-profile .stat-item svg, 
        .profile-modal-container.enemy-profile h3 { color: #f87171; }
        .profile-modal-container.enemy-profile #edit-char-btn { background-color: #991b1b; }
        .profile-modal-container.enemy-profile #edit-char-btn:hover { background-color: #ef4444 !important; }

        .profile-char-image { 
            width: 100%; 
            height: 100%; 
            background-size: cover; 
            background-position: center 20%; 
        }
        .profile-stats-panel { 
            padding: 2.5rem;
            background-color: rgba(0,0,0,0.1); 
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        .profile-char-name { font-size: 2.5rem; font-weight: bold; color: var(--accent-primary); margin-bottom: 0.5rem; }
        .profile-char-type { font-size: 1rem; color: var(--text-secondary); margin-bottom: 2rem; flex-shrink: 0; }
        .profile-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; flex-shrink: 0; }
        .stat-item { display: flex; align-items: center; gap: 0.75rem; }
        .stat-item svg { width: 24px; height: 24px; color: var(--accent-secondary); }
        .stat-item .value { font-size: 1.25rem; font-weight: bold; }
        .stat-item .label { font-size: 0.8rem; color: var(--text-tertiary); }
        
        .profile-content-scroll {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 1rem;
            margin-right: -1rem;
        }
        /* Make sure scrollbars are themed */
        .profile-content-scroll::-webkit-scrollbar { width: 8px; }
        .profile-content-scroll::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        .profile-content-scroll::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        .profile-content-scroll::-webkit-scrollbar-thumb:hover { background: var(--accent-secondary); }

        #profile-modal #close-modal-btn { position: absolute; top: 1rem; right: 1rem; z-index: 10; background: none; border: none; }
        
        /* NEW: Fix for Edit Modal content overflow */
        .profile-modal-container[style*="grid-template-columns: 1fr"] {
             height: auto; /* Allow height to shrink/grow */
             min-height: 400px;
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .p-6 {
            display: flex;
            flex-direction: column;
            height: 100%; /* Ensure content panel takes full height */
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4 {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 1rem; /* Adjust padding for scrollbar */
            margin-right: -1rem;
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar { width: 8px; }
        /* Apply themed scrollbars to edit modal */
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-thumb:hover { background: var(--accent-secondary); }


        /* User Info Button Style */
        .info-button {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .info-button:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        /* NEW: Skill Button Pill Shape and Glow */
        .skill-btn {
            border-radius: 9999px; /* Pill shape */
            padding: 0.5rem 1rem;
            transition: all 0.3s ease;

            /* --- 아래 4줄을 추가/수정하세요 --- */
            background-color: transparent; 
            color: var(--bg-primary); /* 텍스트 색상을 배경과 대비되게 변경 */
            font-weight: bold; /* 텍스트를 굵게 */
            border: 1px solid var(--accent-primary);
        }
        
        .skill-btn:not([disabled]):hover {
            box-shadow: 0 0 10px var(--skill-ring-color), 0 0 5px var(--accent-primary) inset;
        }

        .skill-btn.ring-2 {
             box-shadow: 0 0 10px var(--skill-ring-color) !important;
        }

        /* NEW: Horizontal button group for utility controls */
        #utility-controls {
            position: fixed;
            bottom: 8px;
            right: 8px;
            z-index: 50;
            display: flex;
            gap: 8px; /* Spacing between buttons */
            align-items: flex-end;
        }

        /* NEW: Stylish Turn Box */
        #turn-status.stylish-turn-box {
            /* Background: Darker gradient of accent color */
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.1));
            backdrop-filter: blur(2px);
            border: 2px solid var(--accent-primary);
            box-shadow: 0 0 15px rgba(212, 183, 131, 0.3); /* Lighter glow for the box */
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
        }
        html.light #turn-status.stylish-turn-box {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.1));
            box-shadow: 0 0 15px rgba(140, 106, 72, 0.2);
        }

        #turn-status.stylish-turn-box p {
            /* Set '현재 턴:' text color to primary accent (scrollbar thumb color) */
             color: var(--accent-primary) !important; 
             font-weight: bold;
        }

        #turn-status.stylish-turn-box #current-turn-char {
             color: var(--accent-primary); /* Use accent primary for the name highlight */
        }
        
        /* UPDATED: Stylish Unit Summary Box - Removed background/borders for transparent look */
        #unit-summary {
             /* background-color: var(--summary-box-bg); REMOVED */
             /* border: 1px solid var(--border-secondary); REMOVED */
             border-radius: 8px;
             padding: 0.75rem 0; /* Reduced vertical padding slightly */
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: 1rem;
             text-align: center;
             /* box-shadow: inset 0 0 5px rgba(0,0,0,0.1); REMOVED */
        }
        #remaining-pc, #remaining-enemy {
            background-color: transparent; /* Make inner boxes transparent */
            padding: 0; /* Remove inner padding */
            border-radius: 0;
            border: none;
        }

        /* NEW: Custom styles for the large gradient numbers */
        .summary-count {
            font-size: 3rem; /* Large font size for emphasis */
            font-weight: 700;
            display: inline-block;
            line-height: 1;
            /* Apply Gradiant Text effect */
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            transition: all 0.3s;
        }
        #pc-count.summary-count {
            background-image: linear-gradient(180deg, var(--gradient-start), var(--pc-color));
        }
        #enemy-count.summary-count {
            background-image: linear-gradient(180deg, var(--gradient-start), var(--enemy-color));
        }
       /* --- 아래 코드로 기존 턴 알림 CSS를 모두 교체해주세요 --- */

        /* NEW: 화면을 어둡게 만드는 백드롭 스타일 */
        #turn-announcement-backdrop {
            display: none; /* 평소에는 숨김 */
            position: fixed;
            inset: 0; /* top, right, bottom, left를 모두 0으로 설정 */
            background-color: rgba(0, 0, 0, 0.75);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 100; /* 텍스트 바로 아래에 위치 */
            pointer-events: none; /* 클릭 방지 */
        }

        #turn-announcement-backdrop.visible {
            display: block;
            opacity: 1;
        }

        /* UPDATED: Turn Announcement Banner Styles */
        #turn-announcement {
            display: none;
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101; /* 백드롭 위에 위치 */
            
            color: var(--turn-highlight-color); 
            font-family: 'Cinzel', serif;
            font-weight: bold;
            text-align: center;
            white-space: nowrap;

            text-shadow: 
                -2px -2px 0 #000,  
                 2px -2px 0 #000,
                -2px  2px 0 #000,
                 2px  2px 0 #000,
                 0 0 15px rgba(0,0,0,0.8);
        }

        /* NEW: 텍스트 포맷을 위한 스타일 */
        #turn-announcement .round-text {
            display: block;
            font-size: 1.5rem;
            font-weight: normal;
            opacity: 0.8;
            margin-bottom: 0.5rem;
            letter-spacing: 1px; /* 자간 추가 */
        }

        #turn-announcement .turn-text {
            display: block;
            font-size: 3.5rem;
        }

        /* Class to trigger the animation */
        #turn-announcement.animate-turn {
            display: block;
            animation: turn-announce-animation 2.5s ease-in-out forwards;
        }
 /* --- 이동 취소 & 턴 종료 버튼 스타일 --- */

        #undo-move-btn, #end-turn-btn {
            color: white;
            border: none;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #undo-move-btn:hover, #end-turn-btn:hover {
            transform: translateY(-2px); /* 살짝 떠오르는 효과 */
            filter: brightness(1.15); /* 더 밝아지는 효과 */
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        /* 이동 취소 버튼 - 회색 계열 그라데이션 */
        #undo-move-btn {
            background-image: linear-gradient(to top, #4b5563, #6b7280);
            color: var(--text-primary);
        }

        /* 턴 종료 버튼 - 테마 색상(금색) 계열 그라데이션 */
        #end-turn-btn {
            background-image: linear-gradient(to top, var(--accent-secondary), var(--turn-highlight-color));
            color: var(--bg-primary); /* 밝은 배경에 어두운 글씨로 가독성 확보 */
        }
        /* UPDATED: Keyframes for the announcement animation */
        @keyframes turn-announce-animation {
            0% {
                transform: translateX(-150vw);
                opacity: 0;
            }
            15% {
                transform: translateX(-50%);
                opacity: 1;
            }
            45% {
                transform: translateX(-50%);
                opacity: 1;
                /* 기존 그림자 유지 */
                text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 15px rgba(0,0,0,0.8);
            }
            50% {
                /* 변경됨: 텍스트와 같은 색으로 은은하게 빛나는 효과 */
                text-shadow: 
                    -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000,
                    0 0 10px var(--turn-highlight-color); /* <-- 이 부분이 은은한 빛 효과 */
            }
            55% {
                /* 다시 기존 그림자로 복귀 */
                transform: translateX(-50%);
                opacity: 1;
                text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 15px rgba(0,0,0,0.8);
            }
            85% {
                transform: translateX(-50%);
                opacity: 1;
            }
            100% {
                transform: translateX(150vw);
                opacity: 0;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 overflow-x-hidden pt-60">

    <!-- NEW: Utility Control Group (Bottom Right) -->
    <div id="turn-announcement-backdrop"></div> <div id="turn-announcement"></div>
    <div id="utility-controls">
        <button id="user-info-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
        </button>
        <button id="theme-toggle-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110">
            <svg id="theme-icon-sun" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
            <svg id="theme-icon-moon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
        </button>
        <button id="admin-panel-btn" class="text-white font-bold p-3 rounded-full shadow-lg z-50 transition-transform hover:scale-110" style="background-color: var(--accent-primary); color: var(--bg-primary) !important;">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
        </button>
    </div>

    <!-- User Info Modal -->
    <div id="user-info-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[80] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-md">
            <h3 class="text-2xl font-bold mb-4 font-title" style="color: var(--accent-primary);">내 정보 및 게임 코드</h3>
            
            <div class="mb-4 p-3 border border-border-secondary text-sm rounded-md">
                <p class="font-semibold text-gray-400 mb-1">게임 코드:</p>
                <div class="flex items-center gap-2">
                    <input readonly id="user-info-game-id-display" class="form-input text-center text-sm p-1 flex-grow" style="background-color: var(--bg-game-id);">
                    <button id="user-info-copy-btn" class="p-2 bg-gray-600 hover:bg-gray-500 rounded-md">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    </button>
                </div>
            </div>

            <div class="mb-4 p-3 border border-border-secondary text-sm rounded-md">
                <p class="font-semibold text-gray-400 mb-1">현재 인증:</p>
                <span id="user-info-auth-char" class="font-bold text-lg" style="color: var(--accent-primary);">비로그인</span>
                <p class="text-xs text-gray-500 mt-1">로그인하여 캐릭터 제어 권한을 얻으세요.</p>
                <div class="mt-3 flex gap-2">
                    <button id="user-info-login-btn" class="text-sm bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 flex-grow hidden">캐릭터 로그인</button>
                    <button id="user-info-logout-btn" class="text-sm bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 flex-grow hidden">로그아웃</button>
                </div>
            </div>

            <button id="close-user-info-modal-btn" class="w-full mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2">닫기</button>
        </div>
    </div>
    <!-- End User Info Modal -->

    <!-- Game Lobby Modal -->
    <div id="game-lobby-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[100]">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-md">
            <h2 class="text-3xl font-bold mb-6 text-center" style="color: var(--accent-primary);">게임 참가</h2>
            <p class="text-center mb-6" style="color: var(--text-secondary);">새 게임을 만들거나, 친구에게 받은 코드를 입력하여 참가하세요.</p>
            <div class="space-y-4">
                <button id="create-game-btn" class="w-full bg-green-600 text-black font-bold py-3 px-4 transition-transform hover:scale-105">새 게임 만들기</button>
                <div class="flex items-center"><hr class="flex-grow border-gray-600"><span class="px-4 text-gray-400">또는</span><hr class="flex-grow border-gray-600"></div>
                <div class="flex gap-2">
                    <input type="text" id="game-id-input" placeholder="게임 코드 입력" class="form-input flex-grow">
                    <button id="join-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4">참가하기</button>
                </div>
            </div>
        </div>
    </div>

    <!-- PC Login Modal (New) -->
    <div id="pc-login-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[90] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 font-title" style="color: var(--accent-primary);">캐릭터 로그인</h3>
            <p class="mb-4 text-gray-400">제어할 캐릭터 이름과 초기 비밀번호(1234)를 입력하세요.</p>
            <select id="char-login-name-select" class="form-input mb-4"></select>
            <input type="password" id="char-login-password-input" class="form-input text-center" placeholder="비밀번호 (초기: 1234)">
            <p id="char-login-error" class="text-red-500 text-sm mt-2 h-4"></p>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-char-login-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4">취소</button>
                <button id="submit-char-login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4">확인</button>
            </div>
        </div>
    </div>
    
    <!-- Character Selection Overlay -->
    <div id="character-selection-overlay" class="flex flex-col justify-start fixed top-0 left-0 w-full z-40">
        <div id="selection-list-wrapper" class="overflow-hidden h-full flex items-center transition-opacity duration-300 ease-in-out">
            <div id="selection-list" class="flex mx-auto p-4 gap-4 max-w-7xl w-full overflow-x-auto whitespace-nowrap justify-start">
                 <div class="text-white/70 text-lg w-full text-center p-4">인증 중...</div>
            </div>
        </div>
        <!-- NEW: Toggle button moved to the right -->
        <button id="overlay-toggle" class="absolute top-full right-4 transform bg-gray-700/90 hover:bg-gray-600/90 text-white p-2 rounded-b-lg z-50 transition-colors shadow-lg">
             <svg id="toggle-icon" class="w-5 h-5 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>
        </button>
    </div>
    
    <!-- Main Content Area -->
    <div class="w-full max-w-7xl mx-auto flex flex-col lg:flex-row gap-8">
        <!-- Left: Control Panel -->
        <div class="panel lg:w-1/4 w-full p-6 shadow-lg flex flex-col">
            <div>
                <div class="flex justify-between items-center mb-2">
                    <h1 class="text-xl font-bold font-title" style="color: var(--accent-primary);">게임 상태</h1>
                </div>
                
                <!-- UPDATED: Remaining Units Summary (Applied Stylish Box, now transparent) -->
                <div id="unit-summary" class="mb-4">
                    <div id="remaining-pc" class="text-center">
                        <p class="text-xs text-gray-400">남은 아군</p>
                        <span id="pc-count" class="summary-count">0</span>
                    </div>
                    <div id="remaining-enemy" class="text-center">
                        <p class="text-xs text-gray-400">남은 적군</p>
                        <span id="enemy-count" class="summary-count">0</span>
                    </div>
                </div>

                <!-- Game ID Display (REMOVED from UI flow) -->
                 <div id="game-id-container" class="hidden">
                    <p class="text-xs font-semibold" style="color: var(--text-secondary);">게임 코드:</p>
                    <div class="flex items-center gap-2 mt-1">
                        <input readonly id="game-id-display" class="form-input text-center text-sm p-1" style="background-color: var(--bg-game-id);">
                        <button id="copy-game-id-btn" class="p-2 bg-gray-600 hover:bg-gray-500">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                        </button>
                    </div>
                </div>
                <!-- Auth Status (Hidden, moved to User Info Modal) -->
                <div id="auth-status" class="hidden">
                    <p class="font-semibold text-gray-400">현재 인증:</p>
                    <span id="current-auth-char" class="text-yellow-400 font-bold">비로그인</span>
                    <button id="login-btn" class="text-xs ml-2 text-indigo-500 hover:text-indigo-300 hidden">로그인</button>
                    <button id="logout-btn" class="text-xs ml-2 text-red-500 hover:text-red-300 hidden">로그아웃</button>
                </div>
                <!-- End Hidden Elements -->

                <div id="turn-status" class="mb-4 stylish-turn-box" >
                    <p class="text-sm font-semibold" style="color: var(--accent-primary);">현재 턴:</p>
                    <div id="current-turn-char" class="text-xl font-bold font-title" style="color: var(--accent-secondary);">준비 중...</div>
                </div>
                <div id="skill-controls" class="mt-4 pb-4 border-b border-border-secondary">
                     <p class="text-sm" style="color: var(--text-tertiary);">캐릭터를 선택하면 스킬이 표시됩니다.</p>
                </div>
                <div id="character-list" class="mt-4 flex-grow">
                    <h2 class="text-lg font-bold pb-2 mb-2 font-title" style="color: var(--text-secondary); border-bottom: 1px solid var(--border-secondary);">캐릭터 상태</h2>
                    <div id="char-list-content" class="max-h-96 overflow-y-auto space-y-2">
                        <p style="color: var(--text-tertiary);" class="text-sm">게임에 참여해주세요...</p>
                    </div>
                </div>
            </div>
            <div class="mt-auto pt-4">
                <button id="leave-game-btn" class="w-full bg-red-600 font-bold py-2 px-4">게임 나가기</button>
            </div>
        </div>

        <!-- Center: Game Board -->
        <div class="lg:w-2/4 w-full flex items-center justify-center">
            <div id="game-board" class="shadow-inner"></div>
        </div>

        <!-- Right: Game Log -->
        <div id="log-panel" class="panel lg:w-1/4 w-full p-6 shadow-lg">
             <h2 class="text-lg font-bold pb-2 mb-4 font-title" style="color: var(--text-secondary); border-bottom: 1px solid var(--border-secondary);">게임 로그</h2>
             <ul id="game-log-list" class="h-[75vh] overflow-y-auto space-y-2 text-sm pr-2">
                <li class="log-system">게임 로그를 기다리는 중...</li>
             </ul>
        </div>
    </div>

    <!-- Modals -->
    <div id="profile-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-50 hidden"><div id="modal-content" class="w-full max-w-[900px]"></div></div>
    <div id="custom-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-50 hidden"><div id="custom-modal-content" class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm"><h3 id="custom-modal-title" class="text-xl font-bold mb-4 font-title"></h3><p id="custom-modal-message" class="mb-6"></p><div id="custom-modal-buttons" class="flex justify-end gap-4"></div></div></div>
    <div id="admin-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[60] hidden"><div id="admin-modal-content" class="modal-content rounded-md shadow-2xl p-8 w-full max-w-3xl max-h-[90vh] overflow-y-auto"><div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">관리자 패널</h3><button id="close-admin-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div><div id="admin-skill-list" class="space-y-4"></div></div></div>
    <div id="admin-password-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[70] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 font-title">관리자 인증</h3>
            <p class="mb-4 text-gray-400">관리자 비밀번호를 입력하세요.</p>
            <input type="password" id="admin-password-input" class="form-input text-center">
            <p id="admin-password-error" class="text-red-500 text-sm mt-2 h-4"></p>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-admin-login-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4">취소</button>
                <button id="submit-admin-login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4">확인</button>
            </div>
        </div>
    </div>
    
    <!-- Map Edit Modal (New) -->
    <div id="map-edit-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[65] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-lg max-h-[90vh] overflow-y-auto">
            <!-- X 버튼 추가 및 제목 컨테이너 수정 -->
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">맵 편집 모드 (관리자)</h3>
                <button id="close-map-edit-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button>
            </div>
            <!-- End Modified header -->
            <p class="mb-4 text-gray-400">보드 칸을 클릭하여 지형을 설정하세요. 준비 단계에서만 작동합니다.</p>
            <div class="space-y-4">
                <div class="flex gap-4 p-4 border border-gray-700 rounded-md">
                    <button data-tile-type="normal" class="tile-select-btn flex-grow p-3 bg-gray-600 hover:bg-gray-500 text-white">일반 칸</button>
                    <button data-tile-type="obstacle" class="tile-select-btn flex-grow p-3 bg-gray-700 hover:bg-gray-600 text-white tile-obstacle">장애물 (이동 불가) 🚫</button>
                    <button data-tile-type="damage" class="tile-select-btn flex-grow p-3 bg-red-800 hover:bg-red-700 text-white tile-damage">대미지 칸 (턴 시작 시 $10$ 피해) 🩸</button>
                </div>
                <div id="map-edit-status" class="text-center font-bold text-lg text-green-400">현재 선택: 일반 칸</div>
                <button id="exit-map-edit-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3">맵 편집 종료</button>
            </div>
        </div>
    </div>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, onSnapshot, doc, updateDoc, query, getDocs, writeBatch, getDoc, setDoc, addDoc, serverTimestamp, orderBy, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // IMPORTANT: In a real environment, these configs should be loaded securely.
    const firebaseConfig = {
        apiKey: "AIzaSyDwTxRX9oUSYVKlhX2k2s7147vQ4MGHj2g",
        authDomain: "battlemap-5525d.firebaseapp.com",
        projectId: "battlemap-5525d",
        storageBucket: "battlemap-5525d.appspot.com",
        messagingSenderId: "907555037353",
        appId: "1:907555037353:web:04034cc19b0f9fe64f49b8"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // --- Global Variables ---
    const BOARD_SIZE = 10;
    let characters = [];
    let selectedCharacterId = null;
    let userId = null;
    let gameId = null; 
    let unsubscribeChars = null;
    let unsubscribeSettings = null;
    let unsubscribeLogs = null;
    let previousTurnCharId = null; // <-- 이 줄을 추가하세요
    let isBoardInitialized = false; 
    let selectedSkill = null; 
    let currentTurnIndex = 0;
    let turnPhase = 'MOVE';
    let isProcessingTurn = false;
    let preMovePosition = null; 
    let gameState = 'PREPARATION';
    let round = 1;
    let maxRounds = 0;
    
    let loggedInCharId = null; 
    let isAdmin = false;       
    let isAdminMoveAllowed = true; 
    const DEFAULT_PC_PASSWORD = "1234";
    
    // NEW: Map/Board State Variables
    let boardTiles = {}; // Stores map features { "x,y": { type: 'obstacle' | 'damage' | 'normal', data: {} } }
    let isMapEditMode = false; // Flag for admin map editing
    let currentTileType = 'normal'; // The tile type the admin is currently placing
    let boardBackgroundImage = ''; // NEW: Background image URL
    let pageBackgroundImage = ''; // <-- 이 줄을 추가하세요
    const DAMAGE_TILE_DAMAGE = 10;
    const MP_REGEN_PER_TURN = 10; // New: Mana regeneration per turn

    const DEFAULT_SKILLS = {
        'move': { id: 'move', name: '이동', type: 'Utility', range: 1, rangeShape: 'diamond', multiplier: 0, icon: '🏃', mpCost: 0, category: 'Utility' }, // 기본 이동 거리를 1로 설정
        'slash': { id: 'slash', name: '베기', type: 'Melee', range: 1, rangeShape: 'diamond', multiplier: 1.5, icon: '⚔️', mpCost: 5, category: 'Attack' },
        'stomp': { id: 'stomp', name: '발 구르기', type: 'Melee', range: 1, rangeShape: 'square', multiplier: 1.2, icon: '💥', mpCost: 8, category: 'Attack'},
        'crosscut': { id: 'crosscut', name: '십자 베기', type: 'Melee', range: 2, rangeShape: 'cross', multiplier: 1.0, icon: '十字', mpCost: 10, category: 'Attack'},
        'binding_chains': { id: 'binding_chains', name: '속박의 사슬', type: 'Melee', range: 1, rangeShape: 'square', multiplier: 1.0, icon: '🔗', mpCost: 20, category: 'Attack', appliesEffect: { id: 'rooted', name: '속박', turns: 2 }},
        'poison': { 
            id: 'poison', 
            name: '중독', 
            type: 'Melee', 
            range: 1, 
            rangeShape: 'diamond', 
            multiplier: 0.5, // 초기 피해는 약하게 설정
            icon: '☠️', 
            mpCost: 15, 
            category: 'Attack',
            // 3턴 동안 턴마다 10의 피해를 주는 효과
            appliesEffect: { id: 'poisoned', name: '중독', turns: 3, value: 10 } 
        },
        'shoot': { id: 'shoot', name: '사격', type: 'Ranged', range: 4, rangeShape: 'diamond', multiplier: 1.0, icon: '🏹', mpCost: 5, category: 'Attack' },
        'fireball': { id: 'fireball', name: '화염구', type: 'Ranged', range: 3, rangeShape: 'square', multiplier: 1.0, icon: '🔥', isAoe: true, aoeRange: 1, aoeShape: 'square', mpCost: 15, category: 'Attack' },
        'heal': { id: 'heal', name: '치유의 빛', type: 'Heal', range: 2, rangeShape: 'diamond', multiplier: 1.0, icon: '✨', targetType: 'ALLY', mpCost: 10, category: 'Support' },
        
        // NEW SKILLS
        'resurrect': { id: 'resurrect', name: '부활의 주문', type: 'Heal', range: 1, rangeShape: 'diamond', multiplier: 0.3, icon: '👼', targetType: 'ALLY_DEAD', mpCost: 50, category: 'Support' }, // HP 30% 부활, MP 0으로
        'hp_transfer': { id: 'hp_transfer', name: '생명력 전달', type: 'Heal', range: 2, rangeShape: 'diamond', multiplier: 1.5, icon: '💖', targetType: 'ALLY', mpCost: 0, hpCost: 20, category: 'Support' }, // HP 20 소모, 30 회복
        'mp_transfer': { id: 'mp_transfer', name: '마나 전달', type: 'Support', range: 2, rangeShape: 'diamond', multiplier: 30, icon: '💧', targetType: 'ALLY', mpCost: 10, category: 'Support' }, // MP 10 소모, 30 MP 전달
    };
    let SKILLS = {};
    
    // 스킬 카테고리 순서 정의
    const SKILL_CATEGORIES = ['Attack', 'Support', 'Heal', 'Utility', 'Defense', 'Other'];


    // --- UI Elements ---
    const gameBoard = document.getElementById('game-board');
    const profileModal = document.getElementById('profile-modal');
    const skillControls = document.getElementById('skill-controls');
    const turnStatus = document.getElementById('current-turn-char');
    const lobbyModal = document.getElementById('game-lobby-modal');
    const pcLoginModal = document.getElementById('pc-login-modal');
    const createGameBtn = document.getElementById('create-game-btn');
    const joinGameBtn = document.getElementById('join-game-btn');
    const gameIdInput = document.getElementById('game-id-input');
    const gameIdContainer = document.getElementById('game-id-container');
    const gameIdDisplay = document.getElementById('game-id-display');
    const copyGameIdBtn = document.getElementById('copy-game-id-btn');
    const adminModal = document.getElementById('admin-modal');
    const adminPasswordModal = document.getElementById('admin-password-modal');
    const leaveGameBtn = document.getElementById('leave-game-btn');
    const currentAuthChar = document.getElementById('current-auth-char');
    const logoutBtn = document.getElementById('logout-btn');
    const loginBtn = document.getElementById('login-btn');
    const mapEditModal = document.getElementById('map-edit-modal'); // NEW map edit modal
    const userInfoBtn = document.getElementById('user-info-btn');
    const userInfoModal = document.getElementById('user-info-modal');


    // --- Game Lobby ---
    function generateGameId() { return Math.random().toString(36).substring(2, 8).toUpperCase(); }

    async function deleteLogsCollection(gameId) {
        if (!gameId) return;
        try {
            const logsRef = collection(db, "games", gameId, "logs");
            const snapshot = await getDocs(logsRef);
            if (!snapshot.empty) {
                const batch = writeBatch(db);
                snapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                console.log(`Logs cleared for game: ${gameId}`);
            }
        } catch (error) {
            console.error("Error clearing logs:", error);
        }
    }

    async function createGame() { await joinGame(generateGameId(), true); }
    async function joinGame(id, isNewGame = false) {
        if (!id || id.trim().length === 0) { showCustomModal("오류", "유효한 게임 코드를 입력해주세요.", [{ text: "확인", class: "bg-red-600" }]); return; }
        gameId = id.trim().toUpperCase();

        if (!isNewGame) {
            const docSnap = await getDoc(doc(db, "games", gameId));
            if (!docSnap.exists()) { showCustomModal("참가 실패", "존재하지 않는 게임 코드입니다.", [{ text: "확인", class: "bg-red-600" }]); gameId = null; return; }
        }

        localStorage.setItem('currentGameId', gameId);
        lobbyModal.classList.add('hidden');
        gameIdDisplay.value = gameId;
        // gameIdContainer.classList.remove('hidden'); // REMOVED: Game ID container is removed from this flow

        if (isNewGame) {
            await deleteLogsCollection(gameId);
            await seedInitialSettings(gameId);
            await seedInitialCharacters(gameId);
            // NEW: Seed initial board tiles (all normal)
            await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: {} });
            await logAction("⚔️ 새로운 게임이 시작되었습니다! 게임 로그가 초기화되었습니다.", "system");
        }
        listenForGameData(gameId);
        openPCLoginModal();
    }
    function leaveGame() { localStorage.removeItem('currentGameId', gameId); location.reload(); }

    // --- Authentication ---
    onAuthStateChanged(auth, (user) => {
        if (user) {
            userId = user.uid;
            const savedGameId = localStorage.getItem('currentGameId');
            if (savedGameId) { joinGame(savedGameId); } 
            else { lobbyModal.classList.remove('hidden'); }
        } else { signInAnonymously(auth).catch((error) => console.error("Anonymous sign-in failed:", error)); }
    });
    
    // --- Data Seeding ---
    async function seedInitialSettings(gameId) { 
        await setDoc(doc(db, 'games', gameId), { 
            skills: DEFAULT_SKILLS, 
            currentTurnIndex: 0, 
            currentTurnCharId: null, 
            adminPassword: "0000", 
            gameState: 'PREPARATION', 
            round: 1, 
            maxRounds: 0, 
            isAdminMoveAllowed: true,
            boardBackgroundImage: '', // Default empty background
            pageBackgroundImage: ''
        }); 
    }
    async function seedInitialCharacters(gameId) {
        const charCollectionRef = collection(db, "games", gameId, "characters");
        const snapshot = await getDocs(charCollectionRef);
        if (snapshot.empty) {
            const batch = writeBatch(db);
            const pcData = [ 
                { name: "User1", img: "", type: 'PC', size: 1, skills: ['slash', 'shoot', 'heal', 'hp_transfer'], statusEffects: [
        // { id: 'defenseUp', name: '결계 강화', turnsRemaining: 2, value: 1.5 },
        // { id: 'rooted', name: '속박의 사슬', turnsRemaining: 1 }
    ], order: 1 }, // Added hp_transfer
                { name: "User2", img: "", type: 'PC', size: 1, skills: ['crosscut', 'resurrect', 'mp_transfer'], statusEffects: [
        // { id: 'defenseUp', name: '결계 강화', turnsRemaining: 2, value: 1.5 },
        // { id: 'rooted', name: '속박의 사슬', turnsRemaining: 1 }
    ], order: 3 }, // Added resurrect, mp_transfer
            ];
            const enemyData = [ 
                { name: "Enemy1", img: "", type: 'ENEMY', size: 1, skills: ['slash'], statusEffects: [
        // { id: 'defenseUp', name: '결계 강화', turnsRemaining: 2, value: 1.5 },
        // { id: 'rooted', name: '속박의 사슬', turnsRemaining: 1 }
    ], order: 2 }, 
                { name: "Enemy2", img: "", type: 'ENEMY', size: 2, skills: ['stomp'], statusEffects: [
        // { id: 'defenseUp', name: '결계 강화', turnsRemaining: 2, value: 1.5 },
        // { id: 'rooted', name: '속박의 사슬', turnsRemaining: 1 }
    ], order: 4 }, 
            ];
            [...pcData, ...enemyData].forEach(char => {
                const charPassword = char.type === 'PC' ? DEFAULT_PC_PASSWORD : ''; 
                // ADDED MP stats
                const newChar = { name: char.name, imageUrl: char.img || '', type: char.type, size: char.size, hp: 100, maxHp: 100, mp: 50, maxMp: 50, minAttack: 12, maxAttack: 18, minDefense: 3, maxDefense: 7, x: null, y: null, skills: char.skills || [], turnOrder: char.order, password: charPassword, isAuto: false, statusEffects: [] };
                batch.set(doc(charCollectionRef), newChar);
            });
            await batch.commit();
        }
    }
    
    // --- Data Listeners ---
    function listenForGameData(gameId) {
        if (unsubscribeSettings) unsubscribeSettings();
        if (unsubscribeChars) unsubscribeChars();
        if (unsubscribeLogs) unsubscribeLogs();

        unsubscribeSettings = onSnapshot(doc(db, 'games', gameId), (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                SKILLS = data.skills || {};
                gameState = data.gameState || 'PREPARATION';
                round = data.round || 1;
                maxRounds = data.maxRounds || 0;
                isAdminMoveAllowed = data.isAdminMoveAllowed !== undefined ? data.isAdminMoveAllowed : true;
                boardBackgroundImage = data.boardBackgroundImage || '';
                pageBackgroundImage = data.pageBackgroundImage || '';
                document.body.style.setProperty('--page-background-image', pageBackgroundImage ? `url('${pageBackgroundImage}')` : 'none');


                const turnCharId = data.currentTurnCharId;

                // --- 여기가 핵심 로직입니다 ---
                // 만약 턴이 실제로 변경되었다면 (그리고 게임이 시작된 상태라면)
                if (gameState === 'STARTED' && turnCharId && turnCharId !== previousTurnCharId) {
                    const currentTurnChar = characters.find(c => c.id === turnCharId);
                    if (currentTurnChar) {
                        showTurnAnnouncement(currentTurnChar.name, round);
                              if (currentTurnChar.isAuto) {
                            // AI 턴 실행 (1초 후)
                            setTimeout(() => {
                                runAutoTurn(currentTurnChar);
                            }, 1000);
                        }
                    }
                }
                // 현재 턴 ID를 "이전 턴 ID"로 기억
                previousTurnCharId = turnCharId;
                // ---------------------------------

                currentTurnIndex = characters.findIndex(c => c.id === turnCharId);
                if (currentTurnIndex === -1) currentTurnIndex = 0;
                if (!adminModal.classList.contains('hidden')) openAdminModal();
                
                onSnapshot(doc(db, 'games', gameId, 'board', 'tiles'), (tileDoc) => {
                    boardTiles = tileDoc.data()?.tiles || {};
                    render();
                });

                render();
            }
        });

        unsubscribeChars = onSnapshot(query(collection(db, "games", gameId, "characters")), (snapshot) => {
            characters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).sort((a, b) => a.turnOrder - b.turnOrder);
            // Ensure MP defaults are set if missing (for older entries)
            characters.forEach(char => {
                if (char.mp === undefined || char.maxMp === undefined) {
                    char.mp = char.maxMp = 50; 
                }
            });
            if (!pcLoginModal.classList.contains('hidden')) populatePCLoginSelect(); 
            render();
        });

        unsubscribeLogs = onSnapshot(query(collection(db, "games", gameId, "logs"), orderBy("timestamp", "desc")), (snapshot) => {
            renderLogs(snapshot.docs.map(doc => doc.data()));
        });
    }
    
   // --- Game Logic ---
    async function logAction(message, type = "system") { if (gameId) await addDoc(collection(db, "games", gameId, "logs"), { message, type, timestamp: serverTimestamp() }); }
    
    // =================================================================
    // 👇 [새로 추가] 어떤 텍스트든 표시할 수 있는 범용 배너 함수
    // =================================================================
    function showBannerAnnouncement(line1, line2, size1 = '1.5rem', size2 = '3.5rem') {
        const announcementEl = document.getElementById('turn-announcement');
        const backdropEl = document.getElementById('turn-announcement-backdrop');
        if (!announcementEl || !backdropEl) return;

        announcementEl.innerHTML = `
            <span class="round-text" style="font-size: ${size1};">${line1}</span>
            <span class="turn-text" style="font-size: ${size2};">${line2}</span>
        `;

        announcementEl.classList.remove('animate-turn');
        backdropEl.classList.remove('visible');
        void announcementEl.offsetWidth; // Reflow
        announcementEl.classList.add('animate-turn');
        backdropEl.classList.add('visible');

        announcementEl.addEventListener('animationend', () => {
            announcementEl.classList.remove('animate-turn');
            backdropEl.classList.remove('visible');
        }, { once: true });
    }

    // --- 기존 showTurnAnnouncement 함수는 이렇게 수정됩니다 ---
    function showTurnAnnouncement(characterName, round) {
        showBannerAnnouncement(`Round ${round}`, `${characterName}의 턴입니다`);
    }

    
    // NEW: Function to check for damage tile and apply damage if necessary
    async function checkAndApplyTileDamage(char) {
        if (char.x === null || char.hp <= 0) return;

        const tileKey = `${char.x},${char.y}`;
        const tile = boardTiles[tileKey];

        if (tile && tile.type === 'damage') {
            const damage = DAMAGE_TILE_DAMAGE;
            const newHp = Math.max(0, char.hp - damage);
            
            await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { hp: newHp });

            let message = `🩸 ${char.name}이(가) 대미지 칸에 서있어 **${damage} 피해**를 입었습니다!`;
            if (newHp === 0) message += `<br>💀 ${char.name}이(가) 쓰러졌습니다!`;
            await logAction(message, "damage");
        }
    }

    // 두 지점 사이의 거리를 계산하는 도우미 함수
    function getDistance(pos1, pos2) {
        if (!pos1 || !pos2) return Infinity;
        return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
    }

    // 자동 턴을 실행하는 메인 AI 함수
    async function runAutoTurn(character) {
        await logAction(`🤖 ${character.name}의 자동 턴을 시작합니다.`, "system");

        // 1. 공격할 대상 찾기 (살아있는 적군)
        const targets = characters.filter(c => c.type !== character.type && c.hp > 0 && c.x !== null);
        if (targets.length === 0) {
            await logAction(`🤖 공격할 대상이 없어 ${character.name}이(가) 턴을 종료합니다.`, "system");
            await nextTurn();
            return;
        }

        // 1.1. 가장 가까운 적을 타겟으로 설정
        let closestTarget = null;
        let minDistance = Infinity;
        targets.forEach(target => {
            const distance = getDistance(character, target);
            if (distance < minDistance) {
                minDistance = distance;
                closestTarget = target;
            }
        });

        // 2. 사용할 스킬 선택 (가장 첫 번째 공격 스킬)
        const attackSkillId = character.skills.find(id => SKILLS[id]?.category === 'Attack');
        if (!attackSkillId) {
            await logAction(`🤖 사용할 공격 스킬이 없어 ${character.name}이(가) 턴을 종료합니다.`, "system");
            await nextTurn();
            return;
        }
        const attackSkill = SKILLS[attackSkillId];

        // 3. 이동 및 공격 위치 계산
        const moveRange = character.moveRange || SKILLS['move']?.range || 1;
        const attackRange = attackSkill.range;
        const characterSize = character.size || 1;

        let bestMovePos = { x: character.x, y: character.y };
        let canAttackAfterMove = false;

        // 3.1. 현재 위치에서 공격 가능한지 확인
        const distanceToTarget = getDistance(character, closestTarget);
        if (distanceToTarget <= attackRange) {
            canAttackAfterMove = true;
        } else {
            // 3.2. 이동해서 공격할 최적의 위치 찾기
            let bestAttackSpot = null;
            let minMoveDistance = Infinity;

            // 이동 가능한 모든 칸을 순회
            for (let dy = -moveRange; dy <= moveRange; dy++) {
                for (let dx = -moveRange; dx <= moveRange; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) > moveRange) continue;

                    const moveX = character.x + dx;
                    const moveY = character.y + dy;

                    if (moveX < 0 || moveY < 0 || moveX >= BOARD_SIZE || moveY >= BOARD_SIZE) continue;
                    if (!canPlaceCharacter(character, moveX, moveY)) continue;
                    
                    const movedPos = { x: moveX, y: moveY };
                    const distanceToTargetAfterMove = getDistance(movedPos, closestTarget);

                    // 이동 후 공격이 가능하다면, 해당 위치를 후보로
                    if (distanceToTargetAfterMove <= attackRange) {
                        canAttackAfterMove = true;
                        // 가장 적게 움직이는 위치를 선택
                        const moveDistance = getDistance(character, movedPos);
                        if (moveDistance < minMoveDistance) {
                            minMoveDistance = moveDistance;
                            bestAttackSpot = movedPos;
                        }
                    }
                }
            }
             if (bestAttackSpot) {
                bestMovePos = bestAttackSpot;
            } else {
                // 3.3. 공격 위치를 못찾았다면, 그냥 타겟에게 가장 가까이 이동
                let closestPosToTarget = bestMovePos;
                let minDistanceToTarget = getDistance(bestMovePos, closestTarget);

                // 다시 이동 가능한 모든 칸을 순회
                for (let dy = -moveRange; dy <= moveRange; dy++) {
                    for (let dx = -moveRange; dx <= moveRange; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) > moveRange) continue;

                        const moveX = character.x + dx;
                        const moveY = character.y + dy;
                        if (moveX < 0 || moveY < 0 || moveX >= BOARD_SIZE || moveY >= BOARD_SIZE) continue;
                        if (!canPlaceCharacter(character, moveX, moveY)) continue;

                        const movedPos = { x: moveX, y: moveY };
                        const dist = getDistance(movedPos, closestTarget);
                        if (dist < minDistanceToTarget) {
                            minDistanceToTarget = dist;
                            closestPosToTarget = movedPos;
                        }
                    }
                }
                bestMovePos = closestPosToTarget;
            }
        }
        
        // 4. 실행: 이동
        const moved = (bestMovePos.x !== character.x || bestMovePos.y !== character.y);
        if (moved) {
            await logAction(`🤖 ${character.name}이(가) (${bestMovePos.x}, ${bestMovePos.y})(으)로 이동합니다.`, "move");
            await updateDoc(doc(db, 'games', gameId, 'characters', character.id), { x: bestMovePos.x, y: bestMovePos.y });
        } else {
            await logAction(`🤖 ${character.name}이(가) 제자리를 유지합니다.`, "system");
        }

        // 5. 실행: 공격 (이동 후 1.5초 뒤)
        setTimeout(async () => {
            if (canAttackAfterMove) {
                await logAction(`🤖 ${character.name}이(가) ${closestTarget.name}을(를) ${attackSkill.name}(으)로 공격!`, "system");
                await executeSkill(character, closestTarget, attackSkillId);
            } else {
                await logAction(`🤖 공격할 수 없어 ${character.name}이(가) 턴을 종료합니다.`, "system");
                await nextTurn();
            }
        }, moved ? 1500 : 500); // 이동했으면 1.5초, 아니면 0.5초 대기
    }
    async function updateTurnIndex(newIndex, reverse = false) {
    if (characters.length === 0 || !gameId) return;
    
    let newRound = round;
    if (!reverse && newIndex < currentTurnIndex) {
        newRound++;
        await logAction(`▶️ 라운드 ${newRound} 시작`, "system");
    } else if (reverse && newIndex > currentTurnIndex) {
        if (newRound > 1) {
            newRound--;
            await logAction(`◀️ 이전 라운드로 돌아갑니다. (라운드 ${newRound})`, "system");
        }
    }
    
    currentTurnIndex = newIndex % characters.length;
    const currentTurnChar = characters[currentTurnIndex];
    const currentTurnCharId = currentTurnChar?.id || null;

    if (maxRounds > 0 && newRound > maxRounds) {
        await logAction(`- 전투 종료: 최대 라운드 도달 -`, "system");
        await showGameSummaryModal("시간 종료", `최대 라운드(${maxRounds})에 도달하여 전투가 종료되었습니다.`);
        return;
    } 
    
    await setDoc(doc(db, 'games', gameId), { round: newRound, currentTurnIndex, currentTurnCharId }, { merge: true });
    
    if (gameState === 'STARTED' && currentTurnChar && !reverse) {

        const effects = currentTurnChar.statusEffects || [];
        if (effects.length > 0) {
            
            for (const effect of effects) {
                if (effect.id === 'poisoned') { // 맹독 효과
                    const damage = effect.value || 10;
                    const newHp = await updateHP(currentTurnChar, -damage, "damage");
                    await logAction(`☠️ ${currentTurnChar.name}이(가) [${effect.name}] 효과로 **${damage}의 피해**를 입었습니다! (HP: ${newHp})`, "damage");
                }
                /* 👇 [수정된 부분] 빠져있던 재생 효과 처리 로직을 추가합니다. */
                if (effect.id === 'regenerating') { // 재생 효과
                    const heal = effect.value || 15;
                    const newHp = await updateHP(currentTurnChar, heal, "heal");
                    await logAction(`🌿 ${currentTurnChar.name}이(가) [${effect.name}] 효과로 **${heal}의 HP**를 회복했습니다! (HP: ${newHp})`, "heal");
                }
            }

            const isGameOver = await checkGameEndCondition();
            if (isGameOver) return;
            
            const updatedEffects = effects
                .map(effect => ({ ...effect, turnsRemaining: effect.turnsRemaining - 1 }))
                .filter(effect => {
                    if (effect.turnsRemaining <= 0) {
                        logAction(`⏱️ ${currentTurnChar.name}의 [${effect.name}] 효과가 사라졌습니다.`, "system");
                        return false;
                    }
                    return true;
                });

            await updateDoc(doc(db, 'games', gameId, 'characters', currentTurnChar.id), {
                statusEffects: updatedEffects
            });
        }
            
        // 1. MP Regeneration
        const newMp = Math.min(currentTurnChar.maxMp, currentTurnChar.mp + MP_REGEN_PER_TURN);
        if (newMp > currentTurnChar.mp) {
            await updateDoc(doc(db, 'games', gameId, 'characters', currentTurnChar.id), { mp: newMp });
            await logAction(`💧 ${currentTurnChar.name}이(가) **${MP_REGEN_PER_TURN} MP**를 회복했습니다.`, "system");
        }
        
        // 2. Tile Damage Check
        await checkAndApplyTileDamage(currentTurnChar);
    }
}

    async function nextTurn() {
        if (characters.length === 0 || !gameId) return;
        turnPhase = 'MOVE';
        selectedSkill = 'move';
        let nextIndex = currentTurnIndex;
        do {
            nextIndex = (nextIndex + 1) % characters.length;
        } while (characters.length > 1 && characters[nextIndex] && (characters[nextIndex].hp <= 0 || characters[nextIndex].x === null));
        
        await updateTurnIndex(nextIndex);
        selectedCharacterId = null;
        // IMPORTANT: Clear UI highlights on turn change
        document.querySelectorAll('.combat-range').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill'));
    }
    
    async function previousTurn() {
        if (characters.length === 0 || !gameId) return;
        turnPhase = 'MOVE';
        selectedSkill = 'move';
        let prevIndex = currentTurnIndex;
        do {
            prevIndex = (prevIndex - 1 + characters.length) % characters.length;
        } while (characters.length > 1 && characters[prevIndex] && (characters[prevIndex].hp <= 0 || characters[prevIndex].x === null));

        await updateTurnIndex(prevIndex, true);
        selectedCharacterId = null;
        // IMPORTANT: Clear UI highlights on turn change
        document.querySelectorAll('.combat-range').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill'));
    }

    // Helper function to handle HP change
    async function updateHP(char, amount, logType) {
        const newHp = Math.min(char.maxHp, Math.max(0, char.hp + amount));
        await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { hp: newHp });
        return newHp;
    }
    
    // Helper function to handle MP change
    async function updateMP(char, amount) {
         const newMp = Math.min(char.maxMp, Math.max(0, char.mp + amount));
         await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { mp: newMp });
         return newMp;
    }


    function findTargetsInAoe(centerX, centerY, range, shape, skillType, attackerType) {
    const affectedCells = new Set();
    for (let dy = -range; dy <= range; dy++) {
        for (let dx = -range; dx <= range; dx++) {
            let inShape = (shape === 'diamond' && Math.abs(dx) + Math.abs(dy) <= range) || 
              (shape === 'square') || 
              (shape === 'cross' && (dx === 0 || dy === 0)); // 👈 십자 모양 로직 추가
            if (inShape) {
                const x = centerX + dx;
                const y = centerY + dy;
                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) affectedCells.add(`${x},${y}`);
            }
        }
    }
    
    const targets = new Set();
    characters.forEach(char => {
        if (char.x !== null) {
            const isEnemy = char.type !== attackerType;
            const isAlly = char.type === attackerType;
            
            let isEligible = false;
            
            // Standard damage/heal targeting
            if ((skillType === 'Heal' || skillType === 'Support') && isAlly && char.hp > 0) isEligible = true;
            if (skillType !== 'Heal' && skillType !== 'Support' && isEnemy && char.hp > 0) isEligible = true;
            
            // Special case for Resurrect
            const skill = SKILLS[selectedSkill];
            if (skill && skill.targetType === 'ALLY_DEAD' && isAlly && char.hp <= 0) isEligible = true;

            if (isEligible) {
                const size = char.size || 1;
                // 캐릭터가 차지하는 모든 칸(size x size)을 순회합니다.
                for (let ex = 0; ex < size; ex++) {
                    for (let ey = 0; ey < size; ey++) {
                        // 캐릭터가 차지하는 칸 중 하나라도 스킬 범위(affectedCells)에 포함되면,
                        // 대상을 'targets'에 추가하고 이 캐릭터에 대한 검사를 중단합니다.
                        if (affectedCells.has(`${char.x + ex},${char.y + ey}`)) {
                            targets.add(char);
                            return; // forEach 루프에서 현재 반복을 종료하고 다음 캐릭터로 넘어갑니다.
                        }
                    }
                }
            }
        }
    });
    return Array.from(targets);
}

    async function applyDamage(attacker, defender, skillId) {
        const skill = SKILLS[skillId];
        if (!skill) return;
        
        // Mana Check
        if (attacker.mp < skill.mpCost) {
             await logAction(`⚠️ ${attacker.name}이(가) 마나가 부족하여 ${skill.name}을(를) 시전하지 못했습니다. (필요: ${skill.mpCost}, 현재: ${attacker.mp})`, "system");
             return false;
        }

        // Consume MP
        await updateMP(attacker, -skill.mpCost);

        const defenderToken = document.querySelector(`.character-token[data-char-id="${defender.id}"]`);
        if (defenderToken) {
            defenderToken.classList.add('hit-animation', 'show-hit-overlay');
            setTimeout(() => {
                defenderToken.classList.remove('hit-animation');
                defenderToken.classList.remove('show-hit-overlay');
            }, 1000);
        }

        const currentAttack = Math.floor(Math.random() * (attacker.maxAttack - attacker.minAttack + 1)) + attacker.minAttack;
        let currentDefense = Math.floor(Math.random() * (defender.maxDefense - defender.minDefense + 1)) + defender.minDefense; // let으로 변경

        if (defender.statusEffects && defender.statusEffects.length > 0) {
            const defenseUpEffect = defender.statusEffects.find(e => e.id === 'defenseUp');
            if (defenseUpEffect) {
                currentDefense *= defenseUpEffect.value; // ex: 1.5배
                logAction(`🛡️ ${defender.name}의 [${defenseUpEffect.name}] 효과! 방어력이 증가합니다.`, "system");
            }

            const defenseDownEffect = defender.statusEffects.find(e => e.id === 'defenseDown');
            if (defenseDownEffect) {
                currentDefense *= defenseDownEffect.value; // ex: 0.5배
                logAction(`🛡️ ${defender.name}의 [${defenseDownEffect.name}] 효과! 방어력이 감소합니다.`, "system");
            }
        }

        const finalDamage = Math.max(1, Math.round((currentAttack * skill.multiplier) - currentDefense));

        const newHp = await updateHP(defender, -finalDamage, "damage");
        
        let message = `💥 ${attacker.name}의 ${skill.name}! ${defender.name}에게 **${finalDamage.toFixed(0)} 피해!**`;
        if (newHp === 0) message += `<br>💀 ${defender.name}이(가) 쓰러졌습니다!`;
        await logAction(message, "damage");
        return true;
    }
    
    // --- Refactored Apply Heal/Support ---
    async function applyHealOrSupport(caster, target, skillId) {
        const skill = SKILLS[skillId];
        if (!skill) return false;
        
        const isResurrect = skillId === 'resurrect';
        const isHpTransfer = skillId === 'hp_transfer';
        const isMpTransfer = skillId === 'mp_transfer';
        
        // MP/HP Cost Check
        if (caster.mp < skill.mpCost || (isHpTransfer && caster.hp <= skill.hpCost)) {
             const resource = isHpTransfer ? 'HP' : 'MP';
             const cost = isHpTransfer ? skill.hpCost : skill.mpCost;
             const current = isHpTransfer ? caster.hp : caster.mp;
             await logAction(`⚠️ ${caster.name}이(가) ${resource}가 부족하여 ${skill.name}을(를) 시전하지 못했습니다. (필요: ${cost} ${resource}, 현재: ${current} ${resource})`, "system");
             return false;
        }
        
        // Consume Resources
        if (skill.mpCost > 0) await updateMP(caster, -skill.mpCost);
        if (skill.hpCost > 0) await updateHP(caster, -skill.hpCost, "damage"); // Self-damage for HP transfer

        // Animation Helper
        const targetToken = document.querySelector(`.character-token[data-char-id="${target.id}"]`);
        if (targetToken) {
            const animationClass = isMpTransfer ? 'heal-animation' : 'heal-animation'; 
            const overlayClass = isMpTransfer ? 'show-heal-overlay' : 'show-heal-overlay';
            targetToken.classList.add(animationClass, overlayClass);
            setTimeout(() => {
                targetToken.classList.remove(animationClass, overlayClass);
            }, 1000);
        }

        let message;
        
        if (isResurrect) {
            // Resurrect: Set HP to 30% of maxHP, set MP to 0. Must be placed (x!=null is checked by eligibility).
            const reviveHp = Math.round(target.maxHp * skill.multiplier);
            await updateDoc(doc(db, 'games', gameId, 'characters', target.id), { 
                hp: reviveHp, 
                mp: 0 
            });
            message = `👼 ${caster.name}의 ${skill.name}! **${target.name}**을(를) **${reviveHp} HP, 0 MP**로 부활시켰습니다.`;
            await logAction(message, "heal");
        } else if (isHpTransfer) {
            // HP Transfer (Healing)
            const healAmount = Math.max(1, Math.round(caster.minAttack * skill.multiplier));
            const newHp = await updateHP(target, healAmount, "heal");
            message = `💖 ${caster.name}이(가) **${skill.hpCost} HP**를 소모하여 ${target.name}에게 **${healAmount} HP**를 전달했습니다. (${target.hp} → ${newHp})`;
            await logAction(message, "heal");
        } else if (isMpTransfer) {
            // MP Transfer
            const mpAmount = skill.multiplier; // Multiplier holds the fixed MP amount (30)
            const newMp = await updateMP(target, mpAmount);
            message = `💧 ${caster.name}이(가) **${skill.mpCost} MP**를 소모하여 ${target.name}에게 **${mpAmount} MP**를 전달했습니다. (${target.mp} → ${newMp})`;
            await logAction(message, "system");
        } else if (skill.type === 'Heal') {
             // Standard Heal
            const baseHeal = Math.floor(Math.random() * (caster.maxAttack - caster.minAttack + 1)) + caster.minAttack;
            const finalHeal = Math.max(1, Math.round(baseHeal * skill.multiplier));
            const newHp = await updateHP(target, finalHeal, "heal");
            message = `✨ ${caster.name}의 ${skill.name}! ${target.name}의 **HP를 ${finalHeal.toFixed(0)} 회복!** (${target.hp} → ${newHp})`;
            await logAction(message, "heal");
        }
        
        return true;
    }

async function applyStatusEffect(target, effectInfo) {
    if (!target || !effectInfo) return;

    // 1. 필수 정보만으로 기본 효과 객체를 생성합니다.
    const newEffect = {
        id: effectInfo.id,
        name: effectInfo.name,
        turnsRemaining: effectInfo.turns,
    };

    // 2. 'value'나 'effectType' 같은 추가 정보가 있을 경우에만 객체에 추가합니다.
    //    이렇게 하면 'undefined' 값이 저장되는 것을 방지할 수 있습니다.
    if (effectInfo.value !== undefined) {
        newEffect.value = effectInfo.value;
    }
    if (effectInfo.effectType) {
        newEffect.effectType = effectInfo.effectType;
    }

    const targetRef = doc(db, 'games', gameId, 'characters', target.id);
    
    const targetDoc = await getDoc(targetRef);
    if (!targetDoc.exists()) return;

    const currentEffects = targetDoc.data().statusEffects || [];

    if (currentEffects.some(e => e.id === newEffect.id)) {
        console.log(`${target.name}은(는) 이미 ${newEffect.name} 효과를 받고 있습니다.`);
        return;
    }

    const updatedEffects = [...currentEffects, newEffect];
    await updateDoc(targetRef, { statusEffects: updatedEffects });

    await logAction(`🔗 ${target.name}이(가) [${newEffect.name}] 효과를 받았습니다! (${newEffect.turnsRemaining}턴 지속)`, "system");
}
    async function showGameSummaryModal(title, message) {
        // 게임 상태를 'ENDED'로 확실하게 변경합니다.
        await setDoc(doc(db, 'games', gameId), { gameState: 'ENDED' }, { merge: true });

        const remainingPCs = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null).length;
        const totalPCs = characters.filter(c => c.type === 'PC').length;
        const remainingEnemies = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null).length;
        const totalEnemies = characters.filter(c => c.type === 'ENEMY').length;

        const resultMessage = `
            ${message}
            <hr class="my-4 border-gray-600">
            <h4 class="font-bold text-lg mb-2">최종 결과</h4>
            <p>남은 아군: ${remainingPCs} / ${totalPCs}</p>
            <p>남은 적군: ${remainingEnemies} / ${totalEnemies}</p>
        `;

        showCustomModal(title, resultMessage, [{ text: "확인", class: "bg-indigo-600" }]);
    }
        async function checkGameEndCondition() {
        const remainingPCs = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null).length;
        const remainingEnemies = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null).length;

        // 아군이 모두 쓰러졌을 경우
        if (remainingPCs === 0) {
            await showGameSummaryModal("패배...", "모든 아군이 쓰러졌습니다.");
            return true; // 게임 종료됨
        } 
        // 적군이 모두 쓰러졌을 경우
        else if (remainingEnemies === 0) {
            await showGameSummaryModal("승리!", "모든 적을 물리쳤습니다.");
            return true; // 게임 종료됨
        }

        return false; // 게임 계속됨
    }
     async function executeSkill(attacker, target, skillId) {
        const skill = SKILLS[skillId];
        if (!skill) return;
        
        let actionSucceeded = false;
        // 임시 변수로 여러 대상들을 저장할 배열
        let affectedTargets = []; 

        if (skill.type === 'Heal' || skill.type === 'Support') {
            if (skill.isAoe) {
                const targets = findTargetsInAoe(target.x, target.y, skill.aoeRange, skill.aoeShape, attacker.type, attacker.type);
                if (targets.length > 0) {
                    await logAction(`✨ ${attacker.name}이(가) ${skill.name}(으)로 광역 ${skill.type === 'Heal' ? '치유' : '지원'}!`, skill.type === 'Heal' ? "heal" : "system");
                    const results = await Promise.all(targets.map(t => applyHealOrSupport(attacker, t, skillId)));
                    actionSucceeded = results.some(r => r);
                } else {
                    await logAction(`✨ ${attacker.name}의 ${skill.name}! 하지만 대상이 없습니다.`, "system");
                }
            } else {
                actionSucceeded = await applyHealOrSupport(attacker, target, skillId);
            }
        } else {
            // Damage Skills (Melee, Ranged)
            if (skill.isAoe) {
                const targets = findTargetsInAoe(target.x, target.y, skill.aoeRange, skill.aoeShape, skill.type, attacker.type);
                if (targets.length > 0) {
                    await logAction(`🔥 ${attacker.name}이(가) ${skill.name}(으)로 광역 공격!`, "damage");
                    const results = await Promise.all(targets.map(t => applyDamage(attacker, t, skillId)));
                    actionSucceeded = results.some(r => r);
                    if (actionSucceeded) affectedTargets = targets; // 성공 시 대상들을 저장
                } else {
                    await logAction(`🔥 ${attacker.name}의 ${skill.name}! 하지만 아무도 맞지 않았습니다.`, "system");
                }
            } else {
                actionSucceeded = await applyDamage(attacker, target, skillId);
                if (actionSucceeded) affectedTargets.push(target); // 성공 시 대상 저장
            }
        }
        
        // 👇 [핵심 추가 부분]
        // 스킬이 성공했고, 적용할 효과(appliesEffect)가 정의되어 있다면
        if (actionSucceeded && skill.appliesEffect) {
            // 영향을 받은 모든 대상에게 효과를 적용합니다.
            for (const t of affectedTargets) {
                // 새로 만든 함수를 여기서 호출!
                await applyStatusEffect(t, skill.appliesEffect);
            }
        }
        
        if (actionSucceeded) {
            // 👇 [수정] 바로 nextTurn()을 호출하기 전에 게임 종료 여부를 확인합니다.
            const isGameOver = await checkGameEndCondition();
            if (!isGameOver) {
                await nextTurn();
            }
        } else {
            render(); 
        }
    }

    async function undoMove() {
        const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
        if (!selectedCharacter || !preMovePosition) return;
        await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), { x: preMovePosition.x, y: preMovePosition.y });
        await logAction(`↩️ ${selectedCharacter.name}이(가) 이동을 취소했습니다.`, "system");
        turnPhase = 'MOVE';
        render();
    }
    
    // --- Rendering & UI ---
    function showCustomModal(title, message, buttons) {
        document.getElementById('custom-modal-title').textContent = title;
        document.getElementById('custom-modal-message').innerHTML = message;
        const buttonsContainer = document.getElementById('custom-modal-buttons');
        buttonsContainer.innerHTML = '';
        buttons.forEach(btn => {
            const buttonEl = document.createElement('button');
            buttonEl.textContent = btn.text;
            buttonEl.className = `${btn.class} text-white font-bold py-2 px-4 transition`;
            buttonEl.onclick = () => { closeModal('custom-modal'); if (btn.onClick) btn.onClick(); };
            buttonsContainer.appendChild(buttonEl);
        });
        document.getElementById('custom-modal').classList.remove('hidden');
    }

    // --- PC Login Handlers ---
    function openPCLoginModal() {
         const pcChars = characters.filter(c => c.type === 'PC');
         if (pcChars.length === 0) {
             return;
         }

         populatePCLoginSelect(pcChars);
         pcLoginModal.classList.remove('hidden');
         document.getElementById('char-login-password-input').focus();
    }

    function populatePCLoginSelect(pcChars = characters.filter(c => c.type === 'PC')) {
        const selectEl = document.getElementById('char-login-name-select');
        selectEl.innerHTML = pcChars.map(char => `<option value="${char.id}">${char.name} (${char.type})</option>`).join('');
    }

    async function handlePCLogin() {
        const charId = document.getElementById('char-login-name-select').value;
        const password = document.getElementById('char-login-password-input').value;
        const errorP = document.getElementById('char-login-error');
        const targetChar = characters.find(c => c.id === charId);

        errorP.textContent = '';

        if (targetChar && targetChar.password === password) {
            loggedInCharId = charId;
            isAdmin = false;
            closeModal('pc-login-modal');
            updateAuthStatus();
            showCustomModal("로그인 성공", `${targetChar.name}로 로그인했습니다.`, [{text:"확인", class:"bg-green-600"}]);
        } else {
            errorP.textContent = '비밀번호가 올바르지 않습니다.';
        }
    }
    
    // Function to update all status indicators
    function updateAuthStatus() {
        const char = characters.find(c => c.id === loggedInCharId);
        let authText = '비로그인';
        let authColor = 'var(--text-secondary)';
        let isUserLoggedIn = false;
        
        if (isAdmin) {
            authText = `관리자 (토큰 이동: ${isAdminMoveAllowed ? '허용' : '제한'}, 맵 편집: ${isMapEditMode ? 'ON' : 'OFF'})`;
            authColor = 'var(--log-admin)';
        } else if (loggedInCharId) {
            authText = `${char ? char.name : 'Unknown PC'} (${char ? char.type : 'PC'})`;
            authColor = 'var(--accent-primary)';
            isUserLoggedIn = true;
        }

        // Update User Info Modal fields
        document.getElementById('user-info-game-id-display').value = gameId || "N/A";
        const authCharSpan = document.getElementById('user-info-auth-char');
        authCharSpan.textContent = authText;
        authCharSpan.style.color = authColor;

        const userInfoLoginBtn = document.getElementById('user-info-login-btn');
        const userInfoLogoutBtn = document.getElementById('user-info-logout-btn');

        if (gameId && characters.some(c => c.type === 'PC') && !isAdmin && !loggedInCharId) {
            userInfoLoginBtn.classList.remove('hidden');
            userInfoLogoutBtn.classList.add('hidden');
        } else if (isAdmin || isUserLoggedIn) {
            userInfoLoginBtn.classList.add('hidden');
            userInfoLogoutBtn.classList.remove('hidden');
        } else {
            userInfoLoginBtn.classList.add('hidden');
            userInfoLogoutBtn.classList.add('hidden');
        }

        // Bind listeners for User Info Modal buttons
        userInfoLoginBtn.onclick = openPCLoginModal;
        userInfoLogoutBtn.onclick = handleLogout;
    }
    
    function handleLogout() {
        loggedInCharId = null;
        isAdmin = false;
        isMapEditMode = false;
        updateAuthStatus();
        closeModal('user-info-modal'); // Close info modal after logout
        render();
        closeModal('map-edit-modal');
    }
    // --- End PC Login Handlers ---

    function initializeBoard() {
        if (isBoardInitialized) return;
        gameBoard.innerHTML = '';
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                gameBoard.appendChild(cell);
            }
        }
        isBoardInitialized = true;
    }

     function highlightRange(char, skillId) {
        document.querySelectorAll('.combat-range').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill'));
        
        if (!char || char.x === null || !SKILLS[skillId]) return;

        const skill = SKILLS[skillId];
        const range = (skill.id === 'move' && char.moveRange !== undefined) ? char.moveRange : skill.range;
        const size = char.size || 1;
        
        const isMove = skill.id === 'move';
        const isAttack = skill.category === 'Attack';
        const isHealOrSupport = skill.category === 'Heal' || skill.category === 'Support';
        
        const shape = skill.rangeShape || 'diamond';
        const validCells = new Set();

        if (isMove) {
            const originX = char.x;
            const originY = char.y;
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) <= range) {
                        const targetX = originX + dx;
                        const targetY = originY + dy;

                        if (canPlaceCharacter(char, targetX, targetY)) {
                            validCells.add(`${targetX},${targetY}`);
                        }
                    }
                }
            }
            

        } else if (isAttack || isHealOrSupport) {
             // Action range (기존 로직과 동일)
            for (let ex = 0; ex < size; ex++) {
                for (let ey = 0; ey < size; ey++) {
                    const originX = char.x + ex, originY = char.y + ey;
                    for (let dy = -range; dy <= range; dy++) {
                        for (let dx = -range; dx <= range; dx++) {
                            let inShape = (shape === 'diamond' && Math.abs(dx) + Math.abs(dy) <= range) ||
                                          (shape === 'square' && Math.abs(dx) <= range && Math.abs(dy) <= range) ||
                                          (shape === 'cross' && ((dx === 0 && Math.abs(dy) <= range) || (dy === 0 && Math.abs(dx) <= range)));
                            if (inShape) {
                                const targetX = originX + dx, targetY = originY + dy;
                                if (targetX >= 0 && targetX < BOARD_SIZE && targetY >= 0 && targetY < BOARD_SIZE) {
                                    validCells.add(`${targetX},${targetY}`);
                                }
                            }
                        }
                    }
                }
            }
            if (!skill.isAoe) {
                for (let ex = 0; ex < size; ex++) {
                    for (let ey = 0; ey < size; ey++) {
                        validCells.delete(`${char.x + ex},${char.y + ey}`);
                    }
                }
            }
        }

        const className = isMove ? 'attack-range-move' : (isHealOrSupport ? 'heal-range-skill' : 'attack-range-skill');
        validCells.forEach(coord => {
            const [x, y] = coord.split(',');
            const cell = document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
            if (cell) cell.classList.add('combat-range', className);
        });
    }
    
    function renderCharacterSelectionOverlay() {
        const selectionList = document.getElementById('selection-list');
        selectionList.innerHTML = characters.length === 0 ? `<div class="text-white/70 text-lg w-full text-center p-4">인증 중...</div>` : '';
        if (characters.length === 0) return;
        
        const renderCard = (char) => {
            const isSelected = char.id === selectedCharacterId, isPlaced = char.x !== null, isDead = char.hp <= 0, isEnemy = char.type === 'ENEMY';
            const canBeDragged = (!isEnemy && (gameState === 'PREPARATION' && !isDead)) || (!isPlaced && !isDead) || (isAdmin && isAdminMoveAllowed);
            
            const charCard = document.createElement('div');
            charCard.className = `char-card-item ${isSelected ? 'selected' : ''} ${isEnemy ? 'enemy-card' : ''}`;
            charCard.dataset.charId = char.id;
            charCard.draggable = canBeDragged;
            
            if (char.imageUrl) charCard.style.backgroundImage = `url(${char.imageUrl})`;
            else charCard.innerHTML = `<span class="card-placeholder font-title">${char.name.charAt(0)}</span>`;
            if (isDead) { charCard.style.filter = 'grayscale(100%) opacity(0.7)'; charCard.draggable = false; }
            
            const infoContainer = document.createElement('div');
            infoContainer.className = 'char-card-info';
            infoContainer.innerHTML = `
                <div class="text-sm font-light ${isEnemy ? 'text-red-300' : 'text-gray-400'}">순서: ${char.turnOrder} (${char.type})</div>
                <div class="font-bold">${char.name} <span class="text-red-400 text-sm">${isDead ? '(사망)' : ''}</span></div>
                <div class="flex justify-between items-center text-sm">
                    <span class="text-white/80">${isPlaced ? `(${char.x}, ${char.y})` : '미배치 (드래그)'}</span>
                    <button class="details-btn">상세</button>
                </div>`;
            
            infoContainer.querySelector('button').onclick = (e) => { e.stopPropagation(); openProfileModal(char); };
            charCard.appendChild(infoContainer);
            charCard.onclick = () => { if (isPlaced && !isDead) { selectedCharacterId = char.id; if(gameState === 'STARTED') { turnPhase = 'MOVE'; selectedSkill = 'move'; preMovePosition = { x: char.x, y: char.y }; } render(); } };
            if (canBeDragged) charCard.ondragstart = (e) => e.dataTransfer.setData('text/plain', char.id);
            return charCard;
        };

        const pcContainer = document.createElement('div');
        pcContainer.className = 'flex gap-4';
        characters.filter(c => c.type === 'PC').forEach(char => pcContainer.appendChild(renderCard(char)));
        selectionList.appendChild(pcContainer);

        const enemyContainer = document.createElement('div');
        enemyContainer.className = 'flex gap-4 pl-4 border-l-2 border-red-800/50';
        characters.filter(c => c.type === 'ENEMY').forEach(char => enemyContainer.appendChild(renderCard(char)));
        selectionList.appendChild(enemyContainer);
    }
    
    function renderSkillButtons(selectedChar, isCurrentTurn) {
        const currentTurnChar = characters[currentTurnIndex];
        const canControlSelectedChar = selectedChar && canControlCharacter(selectedChar.id);
        const isTurnCharacter = selectedChar && currentTurnChar && selectedChar.id === currentTurnChar.id;

        skillControls.innerHTML = '';
         if (gameState === 'PREPARATION') {
            skillControls.innerHTML = `<h3 class="text-lg font-bold mb-2 text-yellow-400">준비 단계</h3><p class="text-sm text-gray-400">캐릭터를 드래그하거나 클릭하여 배치하세요.</p>`;
            return;
        }

        if (!selectedChar || !canControlSelectedChar) { 
            if (selectedChar) {
                skillControls.innerHTML = `<p class="text-sm text-gray-400">현재 ${selectedChar.name}의 턴이 아니거나, 제어 권한이 없습니다.</p>`;
            } else {
                 skillControls.innerHTML = `<p class="text-sm text-gray-400">캐릭터를 선택하면 스킬이 표시됩니다.</p>`; 
            }
            return; 
        }
        
        if (selectedChar.hp <= 0 || selectedChar.x === null) { 
            skillControls.innerHTML = `<p class="text-sm text-gray-500">${selectedChar.hp <= 0 ? '사망함' : '미배치 상태'}</p>`; 
            return; 
        }

        let html = `<h3 class="text-lg font-bold mb-2 ${selectedChar.type === 'ENEMY' ? 'text-red-400' : 'text-green-400'}">${selectedChar.name} 행동</h3>`;

        html += `<p class="text-sm font-semibold text-blue-400 mb-3">MP: ${selectedChar.mp}/${selectedChar.maxMp}</p>`;

        if (isTurnCharacter) {
            const isRooted = selectedChar.statusEffects && selectedChar.statusEffects.some(e => e.id === 'rooted');
            
            if (isRooted && turnPhase === 'MOVE') {
                logAction(`🔗 ${selectedChar.name}이(가) [속박] 상태라 이동할 수 없습니다. 바로 행동 단계로 넘어갑니다.`, "system");
                turnPhase = 'ACTION'; 
                selectedSkill = null; 
                preMovePosition = { x: selectedChar.x, y: selectedChar.y };
            }

            if (turnPhase === 'MOVE') {
                html += `<p class="text-sm text-gray-400">이동할 위치를 선택하거나, 캐릭터 위의 '▼'를 클릭하여 이동을 건너뛰세요.</p>`;
            } else { // 'ACTION' 단계일 때
                html += `<div class="flex flex-wrap gap-2">`;
                
                // ... (기존 스킬 버튼 생성 로직은 동일)
                const categorizedSkills = { Attack: [], Support: [], Heal: [], Utility: [] };
                selectedChar.skills.forEach(id => {
                    const skill = SKILLS[id];
                    if (skill && skill.category) {
                        if (categorizedSkills[skill.category]) categorizedSkills[skill.category].push(skill);
                    }
                });
                ['Attack', 'Heal', 'Support', 'Utility'].forEach(category => {
                    if (categorizedSkills[category].length > 0) {
                        categorizedSkills[category].forEach(skill => {
                            if (skill.id === 'move' && turnPhase === 'ACTION') return; 
                            const isHealSupport = category === 'Heal' || category === 'Support';
                            const ringColor = isHealSupport ? 'ring-green-400' : 'ring-red-400';
                            const canUse = selectedChar.mp >= skill.mpCost && (skill.hpCost === undefined || selectedChar.hp > skill.hpCost);
                            const disabledClass = canUse ? '' : 'opacity-50 cursor-not-allowed';
                            let costText = "";
                            if (skill.mpCost > 0) costText += ` MP ${skill.mpCost}`;
                            if (skill.hpCost > 0) costText += ` HP ${skill.hpCost}`;
                            if (costText) costText = `[${costText.trim()}]`;
                            html += `<button data-skill-id="${skill.id}" data-category="${skill.category}" class="skill-btn ${selectedSkill === skill.id ? `ring-2 ${ringColor}` : ''} text-white p-2 flex items-center flex-col text-xs font-semibold ${disabledClass}" ${canUse ? '' : 'disabled'}>
                                ${skill.icon} ${skill.name}
                                <span class="text-gray-400 text-xs">${costText}</span>
                                </button>`;
                        });
                    }
                });
                html += `</div>`;

                // 👇 [수정된 핵심 로직]
                // '속박' 상태만 아니라면 '행동' 단계에서는 항상 '이동 취소' 버튼을 활성화합니다.
                if (!isRooted) {
                    html += `<button id="undo-move-btn" class="w-full mt-2 bg-gray-500 hover:bg-gray-600 text-white p-2">↩ 이동 취소</button>`;
                }
            }

            html += `<button id="end-turn-btn" class="w-full mt-4 bg-yellow-600 hover:bg-yellow-700 text-white p-2 font-bold">턴 종료</button>`;
            
            if (isAdmin) {
                html += `<p class="text-sm text-purple-400 mt-2">👑 관리자 제어 중</p>`;
            }

        } else if (isAdmin) {
            html += `<p class="text-sm text-purple-400 mt-4">관리자 모드: 턴 제약 없음</p>`;
        } else {
            html += `<p class="text-sm text-gray-400 mt-4">${selectedChar.name}의 차례가 아닙니다.</p>`;
        }
        
        skillControls.innerHTML = html;
        document.getElementById('end-turn-btn')?.addEventListener('click', nextTurn);
        
        const undoBtn = document.getElementById('undo-move-btn');
        if (undoBtn && !undoBtn.disabled) {
            undoBtn.addEventListener('click', undoMove);
        }
        
        document.querySelectorAll('.skill-btn').forEach(btn => btn.onclick = (e) => { 
            selectedSkill = e.currentTarget.dataset.skillId; 
            if (e.currentTarget.dataset.category === 'Utility') {
                const skillId = e.currentTarget.dataset.skillId;
                if (SKILLS[skillId]?.range > 0) turnPhase = 'MOVE';
            } else {
                turnPhase = 'ACTION';
            }
            render(); 
        });
    }
    function updateCharacterList() {
        const listContent = document.getElementById('char-list-content');
        listContent.innerHTML = '';
        
        const remainingPC = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null).length;
        const remainingEnemy = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null).length;

        // Use the new class for styling
        document.getElementById('pc-count').textContent = remainingPC;
        document.getElementById('enemy-count').textContent = remainingEnemy;
        document.getElementById('pc-count').classList.add('summary-count');
        document.getElementById('enemy-count').classList.add('summary-count');

        if (!gameId || characters.length === 0) { listContent.innerHTML = `<p class="text-sm text-gray-400">${!gameId ? '게임에 참여해주세요...' : '캐릭터 로딩 중...'}</p>`; return; }
        
        const currentTurnChar = characters[currentTurnIndex];
        characters.forEach(char => {
            const isTurnChar = currentTurnChar && char.id === currentTurnChar.id && gameState === 'STARTED';
            const charItem = document.createElement('div');
            charItem.className = `p-2 rounded-md flex flex-col cursor-pointer ${char.id === selectedCharacterId ? 'ring-2 ring-green-400' : 'hover:bg-gray-800'} ${isTurnChar && char.x !== null && char.hp > 0 ? 'turn-highlight' : ''}`;
            
            let statusColor = char.hp <= 0 ? 'text-gray-500' : (char.type === 'ENEMY' ? 'text-red-400' : 'text-gray-300');
            if (isTurnChar && char.x !== null && char.hp > 0) statusColor = 'text-yellow-400';
            
            const imageContainer = char.imageUrl 
                ? `<div class="w-8 h-8 rounded-full bg-cover bg-center" style="background-image: url('${char.imageUrl}')"></div>`
                : `<div class="w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center text-lg font-bold font-title">${char.name.charAt(0)}</div>`;

            charItem.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                        ${imageContainer}
                        <span class="font-semibold truncate">${char.name}</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs ${statusColor}">${char.hp <= 0 ? '사망' : (char.x !== null ? `HP: ${char.hp}/${char.maxHp}` : '미배치')}</span>
                        ${isAdmin ? `<button data-char-id="${char.id}" class="delete-char-btn text-red-500 hover:text-red-400 text-xs ml-2 p-1 rounded-sm border border-red-500 hover:border-red-400">삭제</button>` : ''}
                    </div>
                </div>
            `;

            charItem.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                        <img src="${char.imageUrl || ''}" onerror="this.src='https://placehold.co/32x32/1f2937/a0aec0?text=${char.name.charAt(0)}'" class="w-8 h-8 rounded-full object-cover">
                        <span class="font-semibold truncate">${char.name}</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs ${statusColor}">${char.hp <= 0 ? '사망' : (char.x !== null ? `HP: ${char.hp}/${char.maxHp}` : '미배치')}</span>
                        ${isAdmin ? `<button data-char-id="${char.id}" class="delete-char-btn text-red-500 hover:text-red-400 text-xs ml-2 p-1 rounded-sm border border-red-500 hover:border-red-400">삭제</button>` : ''}
                    </div>
                </div>
            `;
            // REMOVE HP/MP BARS HERE
            charItem.onclick = () => { if (char.hp > 0 || isAdmin) { selectedCharacterId = char.id; if(gameState === 'STARTED'){ turnPhase = 'MOVE'; selectedSkill = 'move'; preMovePosition = { x: char.x, y: char.y }; } render(); } };
            listContent.appendChild(charItem);
        });

        if (isAdmin) {
            document.querySelectorAll('.delete-char-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const charIdToDelete = e.currentTarget.dataset.charId;
                    const charName = characters.find(c => c.id === charIdToDelete)?.name || 'Unknown Character';
                    showCustomModal("캐릭터 삭제 확인", `정말로 **${charName}**을(를) 삭제하시겠습니까? (되돌릴 수 없습니다!)`, [
                        { text: "취소", class: "bg-gray-600" },
                        { text: "삭제", class: "bg-red-600", onClick: () => deleteCharacter(charIdToDelete, charName) }
                    ]);
                };
            });
        }
    }

    async function deleteCharacter(charId, charName) {
        if (gameId) {
            await deleteDoc(doc(db, 'games', gameId, 'characters', charId));
            await logAction(`🔥 관리자가 **${charName}** 캐릭터를 삭제했습니다.`, "admin");
            // Reset selected character if it was the one deleted
            if (selectedCharacterId === charId) selectedCharacterId = null;
            if (loggedInCharId === charId) handleLogout();
        }
    }
    
    async function deleteSkill(skillId, skillName) {
        if (!gameId || !isAdmin) return;

        // 1. 이 스킬을 가지고 있는 모든 캐릭터의 스킬 목록에서 해당 스킬 ID를 제거합니다.
        const charUpdateBatch = writeBatch(db);
        let isAnyCharUpdated = false;
        characters.forEach(char => {
            if (char.skills && char.skills.includes(skillId)) {
                isAnyCharUpdated = true;
                const newCharSkills = char.skills.filter(s => s !== skillId);
                const charRef = doc(db, 'games', gameId, 'characters', char.id);
                charUpdateBatch.update(charRef, { skills: newCharSkills });
            }
        });
        
        if (isAnyCharUpdated) {
            await charUpdateBatch.commit();
        }

        // 2. Firestore의 `deleteField`를 사용해 게임 문서의 skills 맵에서 해당 스킬 필드를 직접 제거합니다.
        // 이것이 전체 스킬 맵을 다시 보내는 것보다 훨씬 효율적입니다.
        const gameDocRef = doc(db, 'games', gameId);
        await updateDoc(gameDocRef, {
            [`skills.${skillId}`]: deleteField()
        });
        
        // 3. 로그를 남기고, 선택된 스킬이었다면 선택을 해제합니다.
        await logAction(`🔥 관리자가 **${skillName}** 스킬을 삭제했습니다.`, "admin");
        if (selectedSkill === skillId) selectedSkill = null;
        
        // 💡 중요: 수동으로 모달을 다시 열지 않습니다.
        // onSnapshot 리스너가 데이터 변경을 감지하고, 열려있는 관리자 창의 내용을 자동으로 갱신할 것입니다.
        // openAdminModal(); // <-- 이 줄을 제거하는 것이 핵심입니다.
        
        // 대신 사용자에게 작업이 완료되었음을 알리고 모달을 닫아줍니다.
        closeModal('admin-modal');
        showCustomModal("삭제 완료", `**${skillName}** 스킬이 성공적으로 삭제되었습니다.`, [{ text: "확인", class: "bg-green-600" }]);
    }


    function renderLogs(logs) {
        const logList = document.getElementById('game-log-list');
        logList.innerHTML = logs.map(log => {
            const timeString = log.timestamp ? `[${log.timestamp.toDate().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })}] ` : '';
            return `<li class="log-${log.type}">${timeString}${log.message}</li>`;
        }).join('') || `<li class="log-system">아직 기록된 행동이 없습니다.</li>`;
    }
    
    function render() {
        if (!isBoardInitialized) initializeBoard();
        
        document.querySelectorAll('.cell').forEach(cell => { 
            cell.innerHTML = ''; 
            cell.classList.remove('enemy-threat-range', 'tile-obstacle', 'tile-damage'); 
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            const tile = boardTiles[`${x},${y}`];
            if (tile && tile.type !== 'normal') {
                cell.classList.add(`tile-${tile.type}`);
            }
        });

        if (boardBackgroundImage) {
            gameBoard.style.backgroundImage = `url('${boardBackgroundImage}')`;
        } else {
            gameBoard.style.backgroundImage = 'none';
        }
        document.querySelectorAll('.character-token').forEach(t => t.classList.remove('current-turn-glow'));
        
        const currentTurnChar = characters.length > 0 ? characters[currentTurnIndex] : null;
        updateAuthStatus();

        const selectedChar = characters.find(c => c.id === selectedCharacterId);
        const isMovingPhase = selectedChar && turnPhase === 'MOVE';
        const isTargetingPhase = selectedChar && turnPhase === 'ACTION' && selectedSkill;

        // =================================================================
        // 👇 [핵심 수정] '조준 중' 상태에 따라 게임 보드에 클래스를 추가/제거합니다.
        // =================================================================
        const gameBoardEl = document.getElementById('game-board');
        if (isTargetingPhase) {
            gameBoardEl.classList.add('targeting-active');
        } else {
            gameBoardEl.classList.remove('targeting-active');
        }


        characters.filter(char => char.x !== null).forEach(char => {
            const cell = gameBoard.querySelector(`.cell[data-x='${char.x}'][data-y='${char.y}']`);
            if (cell) {
                const token = document.createElement('div');
                token.className = 'character-token';
                if (char.type === 'ENEMY') token.classList.add('enemy-token');
                
                token.style.width = `${char.size * 100}%`;
                token.style.height = `${char.size * 100}%`;

                if (char.hp <= 0) token.style.filter = 'grayscale(100%) opacity(0.5)';
                token.dataset.charId = char.id;

                // --- 💡 여기가 핵심 수정 부분입니다 ---
                // innerHTML 대신 DOM 요소를 직접 만들어 추가하는 방식으로 변경합니다.

                // 1. 이미지 또는 플레이스홀더 추가
                if(char.imageUrl) {
                    token.style.backgroundImage = `url(${char.imageUrl})`;
                } else {
                    const placeholder = document.createElement('span');
                    placeholder.className = 'token-placeholder font-title';
                    placeholder.textContent = char.name.charAt(0);
                    token.appendChild(placeholder);
                }

                // 2. HP/MP 바 추가
                const hpPercent = (char.hp / char.maxHp) * 100;
                const mpPercent = (char.mp / char.maxMp) * 100;

                const barContainer = document.createElement('div');
                barContainer.className = 'hp-mp-bar-container';
                barContainer.innerHTML = `
                    <div class="hp-bar"><div class="hp-fill" style="width: ${hpPercent}%;"></div></div>
                    <div class="mp-bar"><div class="mp-fill" style="width: ${mpPercent}%;"></div></div>
                `;
                token.appendChild(barContainer);

                // 3. 상태 이상 아이콘 추가 (기존 로직과 동일하지만 이제 안전하게 작동합니다)
                if (char.statusEffects && char.statusEffects.some(e => e.id === 'rooted')) {
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'status-effect-icon';
                    iconDiv.textContent = '🔗';
                    token.appendChild(iconDiv);
                }
                 // 👇 [이 부분을 추가하세요] 👇
                if (char.statusEffects && char.statusEffects.some(e => e.id === 'poisoned')) {
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'status-effect-icon';
                    // 아이콘이 겹치지 않도록 오른쪽 위치를 살짝 조정합니다.
                    iconDiv.style.right = '20px'; 
                    iconDiv.textContent = '☠️';
                    token.appendChild(iconDiv);
                }
                
                // 4. 현재 턴 마커 추가
                if (gameState === 'STARTED' && currentTurnChar && char.id === currentTurnChar.id && char.hp > 0) {
                     token.classList.add('current-turn-glow');
                     const marker = document.createElement('div');
                     marker.className = 'turn-marker';
                     marker.innerHTML = '▼';
                     marker.dataset.charId = char.id;
                     marker.onclick = (e) => {
                         e.stopPropagation();
                         if (canControlCharacter(char.id) && turnPhase === 'MOVE') {
                             selectedCharacterId = char.id;
                             turnPhase = 'ACTION';
                             selectedSkill = null;
                             preMovePosition = { x: currentTurnChar.x, y: currentTurnChar.y };
                             logAction(`⏩ ${currentTurnChar.name}이(가) 이동 단계를 건너뛰었습니다. (제자리 이동)`, "system");
                             render();
                         }
                     };
                     token.appendChild(marker);
                }
                
                // --- 수정 끝 ---
                
                let shouldBeClickThrough = false;
                if (isMovingPhase && char.id === selectedCharacterId && char.size > 1) {
                    shouldBeClickThrough = true;
                }
                if (isTargetingPhase && char.id !== selectedCharacterId && char.size > 1) {
                    shouldBeClickThrough = true;
                }
                if (shouldBeClickThrough) {
                    token.classList.add('token-click-through');
                }
                if (char.id === selectedCharacterId) {
                    token.classList.add('selected-character');
                }

                cell.appendChild(token);
            }
        });

        if (gameState === 'PREPARATION') {
            turnStatus.textContent = `준비 단계 (라운드 ${round})`;
            turnStatus.style.color = 'var(--text-secondary)';
        } else {
             turnStatus.textContent = currentTurnChar ? `Round ${round} - ${currentTurnChar.name}` : (gameId ? "배치 대기 중..." : "게임 시작 대기 중...");
            if(currentTurnChar) turnStatus.style.color = currentTurnChar.type === 'ENEMY' ? '#f87171' : '#34d399';
        }

        document.getElementById('turn-status').classList.add('stylish-turn-box');
        
        const selectedCharForSkills = characters.find(c => c.id === selectedCharacterId);
        const isMyTurn = selectedCharForSkills && currentTurnChar && selectedCharForSkills.id === currentTurnChar.id;

        if (gameState === 'STARTED') {
            const canControl = isAdmin || (isMyTurn && selectedCharForSkills?.id === loggedInCharId);
            let effectiveSkillId = 'move';
            if (selectedCharForSkills && selectedCharForSkills.moveRange !== undefined && SKILLS['move']) {
                 SKILLS['move'].range = selectedCharForSkills.moveRange;
            }
            
            if (turnPhase === 'MOVE' && selectedSkill && SKILLS[selectedSkill]?.category === 'Utility') {
                effectiveSkillId = selectedSkill;
            } else if (turnPhase === 'ACTION' && selectedSkill) {
                effectiveSkillId = selectedSkill;
            }
            
            if (canControl && selectedCharForSkills && effectiveSkillId) {
                highlightRange(selectedCharForSkills, effectiveSkillId);
            } else {
                highlightRange(null, null);
            }
        } else {
            highlightRange(null, null);
        }
        
        renderSkillButtons(selectedCharForSkills, isMyTurn);
        updateCharacterList();
        renderCharacterSelectionOverlay();
    }

    // NEW: Function to remove character placement
    async function removeCharacterPlacement(charId, charName) {
        if (gameId) {
            await updateDoc(doc(db, 'games', gameId, 'characters', charId), { x: null, y: null });
            await logAction(`↩️ ${charName}이(가) 보드에서 배치 해제되었습니다.`, "admin");
            if (selectedCharacterId === charId) selectedCharacterId = null;
            closeModal('profile-modal');
            render();
        }
    }


    window.openProfileModal = (charId) => openProfileModal(characters.find(c => c.id === charId));
    
    function openProfileModal(character, editMode = false) {
        if (!character) return;
        const contentContainer = profileModal.querySelector('#modal-content');
        const isEnemy = character.type === 'ENEMY';
        
        // Authorization Check for action buttons in profile modal
        const canUnplace = isAdmin || (loggedInCharId === character.id && character.type === 'PC' && gameState === 'PREPARATION');
        
        if (editMode) {
            // Admin Edit Mode
             const skillOptions = Object.values(SKILLS); // Include all skills now
            const skillSelects = [1, 2, 3, 4, 5].map(index => { // Increased skill slots for management
                const currentSkill = character.skills?.[index - 1] || 'none';
                return `<div><label class="text-sm text-gray-400">스킬 ${index}</label><select id="edit-skill-${index}" class="form-input mt-1"><option value="none">-- 없음 --</option>${skillOptions.map(skill => `<option value="${skill.id}" ${skill.id === currentSkill ? 'selected' : ''}>${skill.name} (${skill.category})</option>`).join('')}</select></div>`;
            }).join('');
            
            const currentMoveRange = character.moveRange !== undefined 
                ? character.moveRange 
                : SKILLS['move']?.range || 1; // Default to 1
            
            contentContainer.innerHTML = `<div class="profile-modal-container rounded-lg ${isEnemy ? 'enemy-profile' : ''}" style="grid-template-columns: 1fr;">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title text-accent-primary">수정: ${character.name}</h3><button id="close-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div>
                    <div class="space-y-4 max-h-[70vh] overflow-y-auto pr-4">
                        <div><label class="text-gray-400">이름</label><input id="edit-name" class="form-input mt-1" value="${character.name}"></div>
                        <div><label class="text-gray-400">이미지 URL</label><input id="edit-image-url" class="form-input mt-1" value="${character.imageUrl || ''}"></div>
                        ${character.type === 'PC' ? `<div><label class="text-gray-400">PC 비밀번호</label><input id="edit-password" type="text" class="form-input mt-1" value="${character.password || DEFAULT_PC_PASSWORD}"></div>` : ''}
                        <div class="grid grid-cols-3 gap-4">
                            <div><label class="text-gray-400">HP</label><input id="edit-hp" type="number" class="form-input mt-1" value="${character.hp}"></div><div><label class="text-gray-400">최대 HP</label><input id="edit-max-hp" type="number" class="form-input mt-1" value="${character.maxHp}"></div>
                            <div><label class="text-gray-400">MP</label><input id="edit-mp" type="number" class="form-input mt-1" value="${character.mp}"></div><div><label class="text-gray-400">최대 MP</label><input id="edit-max-mp" type="number" class="form-input mt-1" value="${character.maxMp}"></div>
                            <div><label class="text-gray-400">최소 공격력</label><input id="edit-min-attack" type="number" class="form-input mt-1" value="${character.minAttack}"></div><div><label class="text-gray-400">최대 공격력</label><input id="edit-max-attack" type="number" class="form-input mt-1" value="${character.maxAttack}"></div>
                            <div><label class="text-gray-400">최소 방어력</label><input id="edit-min-defense" type="number" class="form-input mt-1" value="${character.minDefense}"></div><div><label class="text-gray-400">최대 방어력</label><input id="edit-max-defense" type="number" class="form-input mt-1" value="${character.maxDefense}"></div>
                            <div><label class="text-gray-400">크기 (예: 1, 2)</label><input id="edit-size" type="number" class="form-input mt-1" value="${character.size || 1}"></div>
                            <div><label class="text-gray-400">턴 순서</label><input id="edit-order" type="number" class="form-input mt-1" value="${character.turnOrder}"></div>
                        </div>
                        <div class="flex items-center gap-2 pt-4 border-t border-gray-700/50">
                            <input type="checkbox" id="edit-is-auto" class="form-checkbox h-5 w-5" ${character.isAuto ? 'checked' : ''}>
                            <label for="edit-is-auto" class="font-bold text-yellow-400">자동 턴 진행 (AI)</label>
                        </div>
                        <h4 class="text-lg font-bold text-gray-300 pt-4">스킬 선택</h4>
                        <div class="grid grid-cols-3 gap-4">${skillSelects}</div>
                        <!-- NEW: Move Range Adjustment (only visible if the character has the default 'move' skill) -->
                        ${character.skills.includes('move') ? 
                            `
                            <h4 class="text-lg font-bold text-gray-300 pt-4 border-t border-gray-700/50">행동력 조정</h4>
                            <div>
                                <label class="text-gray-400">이동력 ('move' 스킬 범위)</label>
                                <input id="edit-move-range" type="number" class="form-input mt-1" value="${currentMoveRange}">
                            </div>
                            ` : ''}
                    </div>
                    <div class="mt-8 flex gap-4 flex-shrink-0">
                       <button id="save-changes-btn" class="w-full bg-green-600 font-bold py-3">저장</button><button id="cancel-edit-btn" class="w-full bg-gray-600 font-bold py-3">취소</button>
                    </div>
                </div>
            </div>`;
            
            document.getElementById('save-changes-btn').onclick = async () => {
                const updates = { 
                    name: document.getElementById('edit-name').value, 
                    imageUrl: document.getElementById('edit-image-url').value.trim(), 
                    hp: parseInt(document.getElementById('edit-hp').value), 
                    maxHp: parseInt(document.getElementById('edit-max-hp').value), 
                    mp: parseInt(document.getElementById('edit-mp').value), 
                    maxMp: parseInt(document.getElementById('edit-max-mp').value), 
                    minAttack: parseInt(document.getElementById('edit-min-attack').value),
                    maxAttack: parseInt(document.getElementById('edit-max-attack').value),
                    minDefense: parseInt(document.getElementById('edit-min-defense').value),
                    maxDefense: parseInt(document.getElementById('edit-max-defense').value),
                    size: parseInt(document.getElementById('edit-size').value) || 1,
                    turnOrder: parseInt(document.getElementById('edit-order').value) || 99, 
                    
                    skills: [
                        document.getElementById('edit-skill-1').value, 
                        document.getElementById('edit-skill-2').value, 
                        document.getElementById('edit-skill-3').value,
                        document.getElementById('edit-skill-4').value,
                        document.getElementById('edit-skill-5').value
                    ].filter(s => s && s !== 'none') 
                };
                if (character.type === 'PC') updates.password = document.getElementById('edit-password').value;
updates.isAuto = document.getElementById('edit-is-auto').checked;
                // NEW: Update 'move' skill range for this specific character if changed.
                if (character.skills.includes('move')) {
                    const newMoveRange = parseInt(document.getElementById('edit-move-range').value) || 1;
                    updates.moveRange = newMoveRange;
                }
                
                if (gameId) await updateDoc(doc(db, 'games', gameId, 'characters', character.id), updates);
                openProfileModal({...character, ...updates}, false);
            };
            document.getElementById('cancel-edit-btn').onclick = () => openProfileModal(character, false);
        } else {
            const statIcon = (type) => ({
                hp: `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>`,
                defense: `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-3z" /></svg>`,
                mp: `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 10v2h14v-2H5z"></path></svg>`,
            }[type] || '');
            const attackIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 12H4M17 12h3"></path></svg>`;
            const sizeIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`;
            const moveIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>`;

            const buildStat = (type, label, value) => {
                let iconHtml = statIcon(type);
                if (type === 'attack') iconHtml = attackIconSvg;
                if (type === 'size') iconHtml = sizeIconSvg;
                if (type === 'move') iconHtml = moveIconSvg;
                return `<div class="stat-item">${iconHtml}<div><div class="value">${value}</div><div class="label">${label}</div></div></div>`;
            }
            
            const effectiveMoveRange = character.moveRange !== undefined 
                ? character.moveRange 
                : SKILLS['move']?.range || 1;

            // 1. 모달의 기본 구조를 먼저 생성합니다.
            contentContainer.innerHTML = `<div class="profile-modal-container rounded-lg ${isEnemy ? 'enemy-profile' : ''}">
                <button id="close-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button>
                <div class="profile-char-image"></div>
                <div class="profile-stats-panel">
                    <div class="profile-content-scroll">
                        <div>
                            <h2 class="profile-char-name font-title">${character.name}</h2>
                            <p class="profile-char-type">${character.type}</p>
                            <div class="profile-stats-grid">
                                ${buildStat('hp', '생명력', `${character.hp} / ${character.maxHp}`)}
                                ${buildStat('mp', '마나', `${character.mp} / ${character.maxMp}`)}
                                ${buildStat('attack', '공격력', `${character.minAttack} - ${character.maxAttack}`)}
                                ${buildStat('defense', '방어력', `${character.minDefense} - ${character.maxDefense}`)}
                                ${buildStat('move', '이동력', `${effectiveMoveRange} 칸`)}
                                ${buildStat('size', '크기', `${character.size}x${character.size}`)}
                            </div>
                        </div>
                        <div class="mt-6">
                            <h3 class="text-xl font-bold mb-3">보유 스킬</h3>
                            <div class="space-y-2">
                                ${character.skills.map(id => SKILLS[id]).filter(Boolean).map(s => {
                                    let costText = "";
                                    if (s.mpCost > 0) costText += `${s.mpCost} MP `;
                                    if (s.hpCost > 0) costText += `${s.hpCost} HP `;
                                    return `<div class="p-3 bg-gray-800/50 rounded-md flex items-center gap-3">
                                        <span class="text-2xl">${s.icon}</span>
                                        <div>
                                            <strong>${s.name} <span class="text-xs text-gray-500">(${s.category})</span></strong>
                                            <small class="block text-gray-400">
                                                ${s.isAoe ? `광역(범위: ${s.aoeRange})` : `단일`}, 사거리: ${s.range}
                                                ${costText ? `| 비용: ${costText}` : ''}
                                            </small>
                                        </div>
                                    </div>`;
                                }).join('') || '<p class="text-gray-500">보유 스킬이 없습니다.</p>'}
                            </div>
                        </div>
                    </div>
                    <div class="mt-auto pt-4 flex-shrink-0 space-y-3">
                       <button id="edit-char-btn" class="w-full bg-gray-600 hover:bg-gray-700 font-bold py-3 px-4">캐릭터 수정</button>
                       ${(character.x !== null && canUnplace) ? `<button id="unplace-char-btn" class="w-full bg-red-700 hover:bg-red-600 font-bold py-3 px-4">보드에서 배치 해제</button>` : ''}
                    </div>
                </div>
            </div>`;
            
            // 2. 이미지 유무에 따라 .profile-char-image 요소를 채웁니다.
            const imageContainer = contentContainer.querySelector('.profile-char-image');
            if (character.imageUrl) {
                imageContainer.style.backgroundImage = `url('${character.imageUrl}')`;
            } else {
                imageContainer.style.backgroundImage = 'none';
                imageContainer.classList.add('flex', 'items-center', 'justify-center');
                imageContainer.innerHTML = `<span class="font-title text-9xl text-gray-600">${character.name.charAt(0)}</span>`;
            }
            
            document.getElementById('edit-char-btn').onclick = () => {
                if (isAdmin) {
                    openProfileModal(character, true);
                } else {
                    showCustomModal("권한 부족", "캐릭터 정보 수정은 관리자만 가능합니다.", [{text:"확인", class:"bg-red-600"}]);
                }
            };
            
            const unplaceBtn = document.getElementById('unplace-char-btn');
            if (unplaceBtn) {
                 unplaceBtn.onclick = () => {
                    showCustomModal("배치 해제 확인", `${character.name}을(를) 보드에서 해제하고 선택창으로 되돌리시겠습니까?`, [
                        { text: "취소", class: "bg-gray-600" },
                        { text: "해제", class: "bg-red-600", onClick: () => removeCharacterPlacement(character.id, character.name) }
                    ]);
                };
            }
        }
        profileModal.classList.remove('hidden');
        document.getElementById('close-modal-btn').onclick = () => closeModal('profile-modal');
    }
    function closeModal(modalId) { document.getElementById(modalId).classList.add('hidden'); }
    
    // --- Admin Functions ---
    
    async function resetBoardPositions() {
        if (!gameId) return;
        const batch = writeBatch(db);
        characters.forEach(char => {
            const charRef = doc(db, 'games', gameId, 'characters', char.id);
            batch.update(charRef, { x: null, y: null });
        });
        await batch.commit();
        await logAction(`🔄 관리자가 모든 캐릭터를 미배치 상태로 되돌렸습니다.`, "admin");
        selectedCharacterId = null;
        render();
    }
async function resetAllCharacterStats() {
    if (!gameId) return;
    
    const charCollectionRef = collection(db, "games", gameId, "characters");
    const snapshot = await getDocs(charCollectionRef);
    
    if (!snapshot.empty) {
        const batch = writeBatch(db);
        snapshot.docs.forEach(charDoc => {
            const charData = charDoc.data();
            batch.update(charDoc.ref, {
                hp: charData.maxHp, // 현재 HP를 최대 HP로 설정
                mp: charData.maxMp, // [수정된 부분] MP도 최대 MP로 설정
                x: null,             // 보드에서 배치 해제
                y: null,
                statusEffects: []    // [추가] 모든 상태 효과(버프/디버프)도 제거
            });
        });
        await batch.commit();
        console.log('All character stats, status effects, and positions have been reset.');
    }
}

    async function resetAllGameData() {
        if (!gameId) return;

        // 👇 [수정] 기존의 두 함수 호출을 새로운 초기화 함수로 교체합니다.
        // await resetBoardPositions();
        // await seedInitialCharacters(gameId);
        await resetAllCharacterStats();

        await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: {} });
        await setDoc(doc(db, 'games', gameId), { 
            gameState: 'PREPARATION', 
            currentTurnIndex: 0, 
            currentTurnCharId: null, 
            round: 1 
        }, { merge: true });

        // 👇 [수정] 로그 메시지를 더 명확하게 변경합니다.
        await logAction(`⚠️ 관리자가 전체 게임을 초기화했습니다. 모든 캐릭터의 HP가 회복되고 재배치를 기다립니다.`, "admin");
    }

    // --- Map Edit Close Functions (Refactored) ---
    
    // 1. 맵 편집 모드를 완전히 끄는 함수 (isMapEditMode = false)
    function confirmExitMapEditMode() {
        isMapEditMode = false; // Mode OFF
        closeModal('map-edit-modal');
        logAction(`🗺️ 관리자가 맵 편집 모드를 종료했습니다.`, "admin");
        updateAuthStatus();
    }

    // 2. 맵 편집 팝업만 일시적으로 숨기는 함수 (isMapEditMode = true 유지)
    function hideMapEditModalTemporarily() {
        closeModal('map-edit-modal');
        // isMapEditMode 상태는 변경하지 않습니다.
        updateAuthStatus();
    }
    
    // 맵 편집 모드 ON
    function openMapEditModal() {
        if (!isAdmin || gameState !== 'PREPARATION') {
             showCustomModal("권한 오류", "맵 편집은 관리자만, 그리고 게임 준비 단계에서만 가능합니다.", [{text:"확인", class:"bg-red-600"}]);
             return;
        }
        // 맵 편집 모드를 열 때 관리자 패널을 닫습니다.
        closeModal('admin-modal'); 

        isMapEditMode = true;
        currentTileType = 'normal';
        mapEditModal.classList.remove('hidden');
        document.getElementById('map-edit-status').textContent = '현재 선택: 일반 칸';
        updateAuthStatus();
    }

    async function saveBoardTile(x, y, type) {
        if (!gameId) return;
        const tileKey = `${x},${y}`;
        const newTiles = { ...boardTiles };

        if (type === 'normal') {
            delete newTiles[tileKey];
        } else {
            newTiles[tileKey] = { type };
        }
        
        await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: newTiles });
        await logAction(`🗺️ 관리자가 (${x}, ${y}) 칸을 ${type === 'obstacle' ? '장애물(🚫)' : (type === 'damage' ? '대미지 칸(🩸)' : '일반 칸')}으로 설정했습니다.`, "admin");
    }
    
    // NEW: Save Background Image
    async function saveBoardBackground(url) {
        if (!gameId) return;
        await setDoc(doc(db, 'games', gameId), { boardBackgroundImage: url }, { merge: true });
        boardBackgroundImage = url;
        await logAction(`🖼️ 관리자가 보드 배경을 설정했습니다.`, "admin");
    }


      function openAdminModal() {
        if (!gameId) return;

        closeModal('map-edit-modal'); 
        
        const container = document.getElementById('admin-modal-content');
        
        // --- 1. 모든 HTML을 하나의 변수에 먼저 만듭니다. ---
        let modalHtml = `<div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">관리자 패널</h3><button id="close-admin-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div>`;

        modalHtml += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
            <h4 class="font-bold text-lg mb-4 text-yellow-400">게임 진행 관리</h4>
            <div class="grid grid-cols-2 gap-4">
                <button id="set-prep-phase-btn" class="w-full bg-blue-600 p-2">준비 단계로 설정</button>
                <button id="set-start-phase-btn" class="w-full bg-green-600 p-2">게임 시작</button>
                <button id="prev-turn-btn" class="w-full bg-gray-600 p-2">이전 턴으로</button>
                <button id="next-turn-btn" class="w-full bg-gray-600 p-2">다음 턴으로</button>
            </div>
            <div class="mt-4 grid grid-cols-2 gap-4">
                <button id="reset-board-pos-btn" class="w-full bg-red-700 p-2">보드 초기화 (미배치)</button>
                <button id="reset-all-game-btn" class="w-full bg-red-900 p-2">⚠️ 전체 게임 재시작</button>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-700">
                 <button id="clear-log-btn" class="w-full bg-yellow-700 hover:bg-yellow-600 p-2">📜 게임 로그 지우기</button>
            </div>
            <div class="mt-4">
                <label for="max-rounds-input" class="block text-sm font-medium text-gray-300">최대 라운드 (0=무한)</label>
                <div class="flex gap-2 mt-1">
                    <input type="number" id="max-rounds-input" class="form-input" value="${maxRounds}">
                    <button id="save-max-rounds-btn" class="bg-indigo-600 p-2 px-4">저장</button>
                </div>
            </div>
            <div class="mt-4 flex items-center">
                <input type="checkbox" id="admin-move-toggle" class="form-checkbox h-5 w-5 text-purple-600 transition duration-150 ease-in-out" ${isAdminMoveAllowed ? 'checked' : ''}>
                <label for="admin-move-toggle" class="ml-2 block text-sm text-gray-300 font-medium">관리자 토큰 이동 허용 (턴 무시)</label>
            </div>
        </div>`;
        modalHtml += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
    <h4 class="font-bold text-lg mb-4 text-yellow-400">방 설정 저장/불러오기</h4>
    <p class="text-sm text-gray-400 mb-4">현재 게임의 모든 설정(캐릭터, 스킬, 맵 등)을 하나의 파일로 저장하거나, 파일에서 불러와 덮어씌웁니다.</p>
    <div class="grid grid-cols-2 gap-4">
        <button id="save-settings-btn" class="w-full bg-blue-600 p-2">설정 파일로 저장하기</button>
        <button id="load-settings-btn" class="w-full bg-green-600 p-2">파일에서 불러오기</button>
    </div>
    <input type="file" id="load-settings-input" class="hidden" accept=".json">
</div>`;

modalHtml += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
            <h4 class="font-bold text-lg mb-4 text-yellow-400">맵/지형 및 배경 관리</h4>
            <button id="open-map-edit-btn" class="w-full bg-purple-600 p-2 font-bold ${gameState !== 'PREPARATION' ? 'opacity-50 cursor-not-allowed' : ''}" ${gameState !== 'PREPARATION' ? 'disabled' : ''}>맵 편집 모드 ${isMapEditMode ? '종료' : '시작'}</button>
            <div class="mt-4 pt-4 border-t border-gray-700/50">
                <label for="board-bg-url" class="block text-sm font-medium text-gray-300">게임 보드 배경 URL</label>
                <div class="flex gap-2 mt-1">
                    <input type="text" id="board-bg-url" class="form-input flex-grow" placeholder="이미지 URL" value="${boardBackgroundImage}">
                    <button id="save-board-bg-btn" class="bg-indigo-600 p-2 px-4">적용</button>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-700/50">
                <label for="page-bg-url" class="block text-sm font-medium text-gray-300">전체 페이지 배경 URL</label>
                <div class="flex gap-2 mt-1">
                    <input type="text" id="page-bg-url" class="form-input flex-grow" placeholder="이미지 URL" value="${pageBackgroundImage}">
                    <button id="save-page-bg-btn" class="bg-indigo-600 p-2 px-4">적용</button>
                </div>
            </div>
        </div>`;

        const skillsByCategory = Object.values(SKILLS).reduce((acc, s) => {
            const category = s.category || 'Other';
            if (!acc[category]) acc[category] = [];
            acc[category].push(s);
            return acc;
        }, {});

        let skillHtml = `<div id="admin-skill-list" class="space-y-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">스킬 목록/편집</h3>`;
        SKILL_CATEGORIES.forEach(category => {
            const skills = skillsByCategory[category];
            if (skills && skills.length > 0) {
                skillHtml += `<div class="mt-4"><h4 class="font-bold text-xl mb-3 text-white border-b border-gray-700 pb-1">${category} 스킬</h4><div class="space-y-3">`;
                skills.sort((a, b) => a.name.localeCompare(b.name)).forEach(s => {
                    const costDisplay = [s.mpCost > 0 ? `${s.mpCost} MP` : '', s.hpCost > 0 ? `${s.hpCost} HP` : ''].filter(Boolean).join(', ');
                    skillHtml += `
                    <div class="bg-gray-800 rounded-md overflow-hidden border border-gray-700">
                        <div class="accordion-header flex justify-between items-center p-3 cursor-pointer hover:bg-gray-700/50 transition-colors">
                            <div>
                                <h4 class="font-bold text-lg">${s.icon} ${s.name} <span class="text-sm text-gray-400">(${s.id})</span></h4>
                                <p class="text-xs text-gray-500 mt-1">비용: ${costDisplay || '없음'} | 범위: ${s.range} | 계수: ${s.multiplier} | 타입: ${s.type}</p>
                            </div>
                            <span class="accordion-icon text-xl transform transition-transform text-gray-400">▼</span>
                        </div>
                        <div class="accordion-content hidden p-4 border-t border-gray-700/50">
                            ${getSkillEditFormHtml(s)}
                        </div>
                    </div>`;
                });
                skillHtml += `</div></div>`;
            }
        });
        skillHtml += `</div>`;
        modalHtml += skillHtml;

        modalHtml += `<div class="mt-8 pt-4 border-t border-gray-700">
            <h4 class="font-bold text-lg mb-2 text-green-400">새 스킬 추가</h4>
            ${getNewSkillFormHtml()}
        </div>`;

        modalHtml += `<div class="mt-8 pt-4 border-t border-gray-700">
            <h4 class="font-bold text-lg mb-2 text-green-400">새 캐릭터/에너미 추가</h4>
            ${getNewCharacterFormHtml()}
        </div>`;

        // --- 2. 완성된 HTML을 화면에 딱 한 번만 그립니다. ---
        container.innerHTML = modalHtml;

        // --- 3. 화면에 모든 요소가 그려진 후에, 모든 이벤트 리스너를 연결합니다. ---

        // 아코디언 기능 연결
        const skillListContainer = container.querySelector('#admin-skill-list');
        if (skillListContainer) {
            skillListContainer.addEventListener('click', e => {
                const header = e.target.closest('.accordion-header');
                if (!header) return;
                const content = header.nextElementSibling;
                const icon = header.querySelector('.accordion-icon');
                if (content && content.classList.contains('accordion-content')) {
                    content.classList.toggle('hidden');
                    icon.classList.toggle('rotate-180');
                }
            });
        }
        
        // [추가] 설정 저장/불러오기 버튼 기능 연결
        document.getElementById('save-settings-btn').onclick = saveSettingsToFile;
        document.getElementById('load-settings-btn').onclick = () => {
            document.getElementById('load-settings-input').click();
        };
        document.getElementById('load-settings-input').onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                loadSettingsFromFile(file);
            }
            // 같은 파일을 다시 로드할 수 있도록 값을 초기화합니다.
            e.target.value = null;
        };
        
        // 나머지 모든 버튼 기능 연결
        document.getElementById('close-admin-modal-btn').onclick = () => closeModal('admin-modal');
        document.getElementById('set-prep-phase-btn').onclick = async () => {
            if (gameId) {
                await updateDoc(doc(db, 'games', gameId), { gameState: 'PREPARATION', currentTurnIndex: 0, currentTurnCharId: null, round: 1 });
                await logAction(`🛠️ 관리자가 게임을 준비 단계로 설정했습니다.`, "system");
                showCustomModal("상태 변경", "게임이 준비 단계로 설정되었습니다. 자유롭게 토큰을 배치하세요.", [{text: "확인", class: "bg-blue-600"}]);
            }
        };
        document.getElementById('set-start-phase-btn').onclick = async () => {
            if (gameId) {
                await updateDoc(doc(db, 'games', gameId), { gameState: 'STARTED' });
                await logAction(`⚔️ 게임이 시작되었습니다! 첫 번째 턴부터 진행합니다.`, "system");
                showBannerAnnouncement("FIGHT!", "게임 시작", '2rem', '4rem');
            }
        };
        document.getElementById('prev-turn-btn').onclick = () => { if (gameId) previousTurn(); };
        document.getElementById('next-turn-btn').onclick = () => { if (gameId) nextTurn(); };
        document.getElementById('save-max-rounds-btn').onclick = async () => {
            if (gameId) {
                const newMaxRounds = parseInt(document.getElementById('max-rounds-input').value) || 0;
                await updateDoc(doc(db, 'games', gameId), { maxRounds: newMaxRounds });
                showCustomModal("설정 저장", `최대 라운드가 ${newMaxRounds > 0 ? newMaxRounds : '무한'}으로 설정되었습니다.`, [{text: "확인", class: "bg-indigo-600"}]);
            }
        };
        document.getElementById('reset-board-pos-btn').onclick = resetBoardPositions;
        document.getElementById('reset-all-game-btn').onclick = () => {
            showCustomModal("전체 초기화 경고", "모든 캐릭터, 맵 지형, 게임 로그가 완전히 초기화됩니다. 계속하시겠습니까?", [
                { text: "취소", class: "bg-gray-600" },
                { text: "확인 (초기화)", class: "bg-red-600", onClick: resetAllGameData }
            ]);
        };
        document.getElementById('clear-log-btn').onclick = () => {
            showCustomModal("로그 삭제 확인", "정말로 게임 로그를 모두 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.", [
                { text: "취소", class: "bg-gray-600" },
                { text: "삭제", class: "bg-red-600", onClick: async () => {
                        await deleteLogsCollection(gameId);
                        await logAction('📜 관리자가 모든 게임 로그를 삭제했습니다.', 'admin');
                    } 
                }
            ]);
        };
        document.getElementById('open-map-edit-btn').onclick = openMapEditModal;
        document.getElementById('save-board-bg-btn').onclick = () => {
            const url = document.getElementById('board-bg-url').value.trim();
            saveBoardBackground(url);
        };
        document.getElementById('save-page-bg-btn').onclick = async () => {
            const url = document.getElementById('page-bg-url').value.trim();
            if (gameId) {
                await setDoc(doc(db, 'games', gameId), { pageBackgroundImage: url }, { merge: true });
                await logAction(`🖼️ 관리자가 전체 페이지 배경을 설정했습니다.`, "admin");
            }
        };
        document.getElementById('admin-move-toggle').onchange = async (e) => {
            const isChecked = e.target.checked;
            if (gameId) {
                await setDoc(doc(db, 'games', gameId), { isAdminMoveAllowed: isChecked }, { merge: true });
                await logAction(`👮 관리자 토큰 이동 권한이 ${isChecked ? '허용' : '제한'}되었습니다.`, "admin-move");
            }
        };
        document.querySelectorAll('.save-skill-btn').forEach(btn => {
            btn.onclick = async e => {
                const id = e.target.dataset.skillId;
                const updated = { ...SKILLS[id], name: document.getElementById(`admin-name-${id}`).value, 
    range: parseFloat(document.getElementById(`admin-range-${id}`).value), 
    rangeShape: document.getElementById(`admin-rangeShape-${id}`).value, // 👈 이 줄을 추가하세요
    multiplier: parseFloat(document.getElementById(`admin-multiplier-${id}`).value), 
    type: document.getElementById(`admin-type-${id}`).value, 
    icon: document.getElementById(`admin-icon-${id}`).value, 
    category: document.getElementById(`admin-category-${id}`).value, 
    mpCost: parseInt(document.getElementById(`admin-mpcost-${id}`).value) || 0, 
    isAoe: document.getElementById(`admin-isAoe-${id}`).checked, 
    aoeRange: parseInt(document.getElementById(`admin-aoeRange-${id}`).value) || 0, 
    aoeShape: document.getElementById(`admin-aoeShape-${id}`).value 
};
                if (document.getElementById(`admin-hasEffect-${id}`).checked) {
                    const effectId = document.getElementById(`admin-effect-id-${id}`).value.trim();
                    const effectName = document.getElementById(`admin-effect-name-${id}`).value.trim();
                    if (effectId && effectName) {
                        updated.appliesEffect = { id: effectId, name: effectName, effectType: document.getElementById(`admin-effect-type-${id}`).value, turns: parseInt(document.getElementById(`admin-effect-turns-${id}`).value) || 0, value: parseInt(document.getElementById(`admin-effect-value-${id}`).value) || 0 };
                    }
                } else {
                    if (updated.hasOwnProperty('appliesEffect')) delete updated.appliesEffect;
                }
                if (gameId) { 
                    const updatedSkills = { ...SKILLS, [id]: updated };
                    await setDoc(doc(db, 'games', gameId), { skills: updatedSkills }, { merge: true });
                    showCustomModal("저장 완료", `'${updated.name}' 스킬 정보가 저장되었습니다.`, [{text: "확인", class: "bg-green-600"}]);
                }
            };
        });
        document.querySelectorAll('.delete-skill-btn').forEach(btn => {
            btn.onclick = (e) => {
                const skillId = e.currentTarget.dataset.skillId;
                const skillName = e.currentTarget.dataset.skillName;
                showCustomModal("스킬 삭제 확인", `**${skillName}** 스킬을 삭제하시겠습니까? 이 스킬을 가진 모든 캐릭터에서 제거됩니다.`, [
                    { text: "취소", class: "bg-gray-600" },
                    { text: "삭제", class: "bg-red-600", onClick: () => deleteSkill(skillId, skillName) }
                ]);
            };
        });
        document.getElementById('add-new-skill-btn').onclick = async () => {
            const newId = document.getElementById('new-skill-id').value.trim();
            if (!newId || SKILLS[newId]) { showCustomModal("오류", "유효하지 않거나 중복된 스킬 ID입니다.", [{text: "확인", class: "bg-red-600"}]); return; }
            const newSkill = { id: newId, name: document.getElementById('new-skill-name').value, type: document.getElementById('new-skill-type').value, icon: document.getElementById('new-skill-icon').value, range: parseFloat(document.getElementById('new-skill-range').value) || 0, multiplier: parseFloat(document.getElementById('new-skill-multiplier').value) || 0, category: document.getElementById('new-skill-category').value, mpCost: parseInt(document.getElementById('new-skill-mpcost').value) || 0, hpCost: 0, isAoe: document.getElementById('new-skill-isAoe').checked, aoeRange: parseInt(document.getElementById('new-skill-aoeRange').value) || 0, aoeShape: document.getElementById('new-skill-aoeShape').value, rangeShape: document.getElementById('new-skill-rangeShape').value };
            if (document.getElementById('new-skill-hasEffect').checked) {
                const effectId = document.getElementById('new-skill-effect-id').value.trim();
                const effectName = document.getElementById('new-skill-effect-name').value.trim();
                if (!effectId || !effectName) { showCustomModal("오류", "지속 효과를 적용하려면 효과 ID와 이름을 모두 입력해야 합니다.", [{text: "확인", class: "bg-red-600"}]); return; }
                newSkill.appliesEffect = { id: effectId, name: effectName, effectType: document.getElementById('new-skill-effect-type').value, turns: parseInt(document.getElementById('new-skill-effect-turns').value) || 0, value: parseInt(document.getElementById('new-skill-effect-value').value) || 0 };
            }
            if (gameId) {
                await setDoc(doc(db, 'games', gameId), { skills: { ...SKILLS, [newId]: newSkill } }, { merge: true });
                showCustomModal("성공", `'${newSkill.name}' 스킬이 추가되었습니다.`, [{text: "확인", class: "bg-green-600"}]);
                openAdminModal(); 
            }
        };
        document.getElementById('add-new-char-btn').onclick = async () => {
            const name = document.getElementById('new-char-name').value.trim();
            if (!name) { showCustomModal("오류", "이름을 입력해야 합니다.", [{text: "확인", class: "bg-red-600"}]); return; }
            const type = document.getElementById('new-char-type').value;
            const skills = document.getElementById('new-char-skills').value.split(',').map(s => s.trim()).filter(Boolean);
            const newChar = { name: name, type: type, imageUrl: document.getElementById('new-char-imageUrl').value.trim(), hp: parseInt(document.getElementById('new-char-hp').value) || 100, maxHp: parseInt(document.getElementById('new-char-hp').value) || 100, mp: parseInt(document.getElementById('new-char-mp').value) || 50, maxMp: parseInt(document.getElementById('new-char-mp').value) || 50, minAttack: parseInt(document.getElementById('new-char-min-attack').value) || 10, maxAttack: parseInt(document.getElementById('new-char-max-attack').value) || 15, minDefense: parseInt(document.getElementById('new-char-min-defense').value) || 3, maxDefense: parseInt(document.getElementById('new-char-max-defense').value) || 7, size: parseInt(document.getElementById('new-char-size').value) || 1, skills: skills, x: null, y: null, turnOrder: characters.length + 1, password: type === 'PC' ? DEFAULT_PC_PASSWORD : '' };
            if (gameId) {
                await addDoc(collection(db, "games", gameId, "characters"), newChar);
                showCustomModal("성공", `'${newChar.name}' 캐릭터가 추가되었습니다.`, [{text: "확인", class: "bg-green-600"}]);
            }
        };

        adminModal.classList.remove('hidden');
    }

    // --- Helper functions for generating HTML forms to keep openAdminModal clean ---
    function getSkillEditFormHtml(s) {
        return `
            <div class="grid grid-cols-4 gap-3 mt-2 text-sm">
                <div class="col-span-2"><label class="block text-xs font-medium text-gray-400">스킬 이름</label><input id="admin-name-${s.id}" class="form-input mt-1" value="${s.name}"></div>
                <div><label class="block text-xs font-medium text-gray-400">분류</label><input id="admin-category-${s.id}" class="form-input mt-1" value="${s.category || 'Other'}"></div>
                <div><label class="block text-xs font-medium text-gray-400">아이콘</label><input id="admin-icon-${s.id}" class="form-input mt-1" value="${s.icon || ''}"></div>
                <div><label class="block text-xs font-medium text-gray-400">사거리 (칸)</label><input id="admin-range-${s.id}" type="number" class="form-input mt-1" value="${s.range}"></div>

<div>
    <label class="block text-xs font-medium text-gray-400">범위 모양</label>
    <select id="admin-rangeShape-${s.id}" class="form-input mt-1 bg-gray-700">
        <option value="square" ${s.rangeShape === 'square' ? 'selected' : ''}>정사각형</option>
        <option value="diamond" ${s.rangeShape === 'diamond' ? 'selected' : ''}>마름모</option>
        <option value="cross" ${s.rangeShape === 'cross' ? 'selected' : ''}>십자</option>
    </select>
</div>
<div><label class="block text-xs font-medium text-gray-400">계수 (배율)</label><input id="admin-multiplier-${s.id}" type="number" step="0.1" class="form-input mt-1" value="${s.multiplier}"></div><div><label class="block text-xs font-medium text-gray-400">MP 비용</label><input id="admin-mpcost-${s.id}" type="number" class="form-input mt-1" value="${s.mpCost || 0}"></div>
                <div><label class="block text-xs font-medium text-gray-400">HP 비용</label><input id="admin-hpcost-${s.id}" type="number" class="form-input mt-1" value="${s.hpCost || 0}"></div>
                <input id="admin-type-${s.id}" type="hidden" value="${s.type}">
            </div>
            <div class="mt-3 pt-3 border-t border-gray-700 space-y-3">
                <div>
                    <h5 class="font-bold text-sm mb-1 text-yellow-400">광역(AoE) 설정</h5>
                    <div class="grid grid-cols-3 gap-3 items-center">
                        <div class="flex items-center gap-2"><input id="admin-isAoe-${s.id}" type="checkbox" class="form-checkbox h-5 w-5" ${s.isAoe ? 'checked' : ''}><label for="admin-isAoe-${s.id}">광역 스킬</label></div>
                        <div><label class="block text-xs font-medium text-gray-400">광역 범위</label><input id="admin-aoeRange-${s.id}" type="number" class="form-input mt-1" value="${s.aoeRange || 0}"></div>
                        <div><label class="block text-xs font-medium text-gray-400">광역 형태</label><select id="admin-aoeShape-${s.id}" class="form-input mt-1 bg-gray-700"><option value="square" ${s.aoeShape === 'square' ? 'selected' : ''}>정사각형</option><option value="diamond" ${s.aoeShape === 'diamond' ? 'selected' : ''}>마름모</option> <option value="cross">십자</option></select></div>
                    </div>
                </div>
                <div>
                    <h5 class="font-bold text-sm mb-1 text-cyan-400">지속 효과(DoT/HoT) 설정</h5>
                    <div class="flex items-center gap-2 mb-2"><input id="admin-hasEffect-${s.id}" type="checkbox" class="form-checkbox h-5 w-5" ${s.appliesEffect ? 'checked' : ''}><label for="admin-hasEffect-${s.id}">지속 효과 적용</label></div>
                    <div class="grid grid-cols-6 gap-3">
                        <div class="col-span-2"><label class="block text-xs font-medium text-gray-400">효과 ID</label><input id="admin-effect-id-${s.id}" class="form-input mt-1" value="${s.appliesEffect?.id || ''}"></div>
                        <div><label class="block text-xs font-medium text-gray-400">효과 이름</label><input id="admin-effect-name-${s.id}" class="form-input mt-1" value="${s.appliesEffect?.name || ''}"></div>
                        <div>
                            <label class="block text-xs font-medium text-gray-400">효과 종류</label>
                            <select id="admin-effect-type-${s.id}" class="form-input mt-1 bg-gray-700">
                                <option value="damage" ${s.appliesEffect?.effectType === 'damage' ? 'selected' : ''}>피해(DoT)</option>
                                <option value="heal" ${s.appliesEffect?.effectType === 'heal' ? 'selected' : ''}>회복(HoT)</option>
                            </select>
                        </div>
                        <div><label class="block text-xs font-medium text-gray-400">지속 턴</label><input id="admin-effect-turns-${s.id}" type="number" class="form-input mt-1" value="${s.appliesEffect?.turns || 0}"></div>
                        <div><label class="block text-xs font-medium text-gray-400">턴당 값</label><input id="admin-effect-value-${s.id}" type="number" class="form-input mt-1" value="${s.appliesEffect?.value || 0}"></div>
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center mt-4 pt-4 border-t border-gray-700/50">
                <button data-skill-id="${s.id}" class="save-skill-btn bg-green-600 p-2 text-sm flex-grow mr-2">저장</button>
                <button data-skill-id="${s.id}" data-skill-name="${s.name}" class="delete-skill-btn bg-red-700 hover:bg-red-600 p-2 text-sm text-white">삭제</button>
            </div>
        `;
    }

    function getNewSkillFormHtml() {
        return `
            <div class="grid grid-cols-4 gap-3">
                <div class="col-span-2"><label class="block text-xs font-medium text-gray-400">스킬 ID (고유값)</label><input id="new-skill-id" class="form-input mt-1"></div>
                <div class="col-span-2"><label class="block text-xs font-medium text-gray-400">스킬 이름</label><input id="new-skill-name" class="form-input mt-1"></div>
                <div><label class="block text-xs font-medium text-gray-400">분류</label><select id="new-skill-category" class="form-input mt-1 bg-gray-700">${SKILL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join('')}</select></div>
                <div><label class="block text-xs font-medium text-gray-400">타입</label><select id="new-skill-type" class="form-input mt-1 bg-gray-700"><option value="Melee">Melee</option><option value="Ranged">Ranged</option><option value="Heal">Heal</option><option value="Utility">Utility</option><option value="Support">Support</option></select></div>
                <div><label class="block text-xs font-medium text-gray-400">아이콘</label><input id="new-skill-icon" class="form-input mt-1"></div>
                <div><label class="block text-xs font-medium text-gray-400">사거리 (칸)</label><input id="new-skill-range" type="number" class="form-input mt-1"></div>
                <div>
    <label class="block text-xs font-medium text-gray-400">범위 모양</label>
    <select id="new-skill-rangeShape" class="form-input mt-1 bg-gray-700">
        <option value="square">정사각형</option>
        <option value="diamond">마름모</option>
        <option value="cross">십자</option>
    </select>
</div>
<div><label class="block text-xs font-medium text-gray-400">계수 (배율)</label><input id="new-skill-multiplier" type="number" step="0.1" class="form-input mt-1"></div>
                <div><label class="block text-xs font-medium text-gray-400">MP 비용</label><input id="new-skill-mpcost" type="number" class="form-input mt-1" value="0"></div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-600">
                <h5 class="font-bold text-md mb-2 text-yellow-400">광역 스킬(AoE) 설정</h5>
                <div class="grid grid-cols-3 gap-4 items-center">
                    <div class="flex items-center gap-2"><input id="new-skill-isAoe" type="checkbox" class="form-checkbox h-5 w-5"><label for="new-skill-isAoe">광역 스킬 여부</label></div>
                    <div><label class="block text-xs font-medium text-gray-400">광역 범위</label><input id="new-skill-aoeRange" type="number" class="form-input mt-1"></div>
                    <div><label class="block text-xs font-medium text-gray-400">광역 형태</label><select id="new-skill-aoeShape" class="form-input mt-1 bg-gray-700"><option value="square">정사각형</option><option value="diamond">마름모</option></select></div>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-600">
                <h5 class="font-bold text-md mb-2 text-cyan-400">지속 효과(DoT/HoT) 설정</h5>
                <div class="flex items-center gap-2 mb-2"><input id="new-skill-hasEffect" type="checkbox" class="form-checkbox h-5 w-5"><label for="new-skill-hasEffect">이 스킬에 지속 효과 적용</label></div>
                <div class="grid grid-cols-5 gap-3">
                    <div><label class="block text-xs font-medium text-gray-400">효과 ID (고유값)</label><input id="new-skill-effect-id" class="form-input mt-1"></div>
                    <div><label class="block text-xs font-medium text-gray-400">효과 이름</label><input id="new-skill-effect-name" class="form-input mt-1"></div>
                    <div>
                        <label class="block text-xs font-medium text-gray-400">효과 종류</label>
                        <select id="new-skill-effect-type" class="form-input mt-1 bg-gray-700">
                            <option value="damage">피해(DoT)</option>
                            <option value="heal">회복(HoT)</option>
                        </select>
                    </div>
                    <div><label class="block text-xs font-medium text-gray-400">지속 턴</label><input id="new-skill-effect-turns" type="number" class="form-input mt-1"></div>
                    <div><label class="block text-xs font-medium text-gray-400">턴당 값</label><input id="new-skill-effect-value" type="number" class="form-input mt-1"></div>
                </div>
            </div>
            <button id="add-new-skill-btn" class="mt-4 bg-blue-600 p-2 w-full">새 스킬 저장</button>
        `;
    }

    function getNewCharacterFormHtml() {
        return `
            <div class="grid grid-cols-2 gap-4">
                <input id="new-char-name" placeholder="이름" class="form-input">
                <select id="new-char-type" class="form-input bg-gray-700"><option value="PC">PC</option><option value="ENEMY">ENEMY</option></select>
                <input id="new-char-imageUrl" placeholder="이미지 URL" class="form-input col-span-2">
                <div class="relative"><input id="new-char-hp" type="number" placeholder=" " class="form-input peer" value="100"><label for="new-char-hp" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">HP (체력)</label></div>
                <div class="relative"><input id="new-char-mp" type="number" placeholder=" " class="form-input peer" value="50"><label for="new-char-mp" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">MP (마나)</label></div>
                <div class="relative"><input id="new-char-min-attack" type="number" placeholder=" " class="form-input peer" value="10"><label for="new-char-min-attack" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최소 공격력</label></div>
                <div class="relative"><input id="new-char-max-attack" type="number" placeholder=" " class="form-input peer" value="15"><label for="new-char-max-attack" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최대 공격력</label></div>
                <div class="relative"><input id="new-char-min-defense" type="number" placeholder=" " class="form-input peer" value="3"><label for="new-char-min-defense" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최소 방어력</label></div>
                <div class="relative"><input id="new-char-max-defense" type="number" placeholder=" " class="form-input peer" value="7"><label for="new-char-max-defense" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최대 방어력</label></div>
                <div class="relative"><input id="new-char-size" type="number" placeholder=" " class="form-input peer" value="1"><label for="new-char-size" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">크기 (1x1, 2x2...)</label></div>
                <input id="new-char-skills" placeholder="스킬 ID (e.g. slash,shoot)" class="form-input">
            </div>
            <button id="add-new-char-btn" class="mt-4 bg-blue-600 p-2 w-full">새 캐릭터 저장</button>
        </div>`;

        adminModal.classList.remove('hidden');
    }

    // --- Event Listeners ---
    
    function canControlCharacter(charId) {
        const char = characters.find(c => c.id === charId);
        if (!char || char.hp <= 0) return false;

        if (isAdmin && isAdminMoveAllowed) return true;

        if (loggedInCharId !== charId) return false; 

        const currentTurnChar = characters[currentTurnIndex];
        if (gameState === 'STARTED' && currentTurnChar && currentTurnChar.id === charId) return true;
        if (gameState === 'PREPARATION' && char.type === 'PC') return true;
        
        return false;
    }

    function isCellOccupied(targetX, targetY, movingCharId = null) {
        // Check for character occupancy
        const isCharOccupied = characters.some(char => {
            if (char.id === movingCharId || char.x === null) return false;
            const size = char.size || 1;
            return targetX >= char.x && targetX < (char.x + size) && targetY >= char.y && targetY < (char.y + size);
        });

        // Check for obstacle tile
        const tileKey = `${targetX},${targetY}`;
        const isObstacle = boardTiles[tileKey]?.type === 'obstacle';
        
        return isCharOccupied || isObstacle;
    }

    function canPlaceCharacter(charToPlace, targetX, targetY) {
        const size = charToPlace.size || 1;
        if (targetX < 0 || targetY < 0 || targetX + size > BOARD_SIZE || targetY + size > BOARD_SIZE) return false;
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                if (isCellOccupied(targetX + i, targetY + j, charToPlace.id)) return false;
            }
        }
        return true;
    }

    async function handlePreparationClick(e) {
        const token = e.target.closest('.character-token');
        const cell = e.target.closest('.cell');
        if (!cell) return;
        const x = parseInt(cell.dataset.x);
        const y = parseInt(cell.dataset.y);

        // NEW: Map Edit Mode takes precedence in PREPARATION phase if admin
        if (isAdmin && isMapEditMode) {
            await saveBoardTile(x, y, currentTileType);
            return;
        }

        if (token) {
            selectedCharacterId = token.dataset.charId;
            render();
        } else if (selectedCharacterId) {
            const targetChar = characters.find(c => c.id === selectedCharacterId);
            const isPC = targetChar?.type === 'PC';

            if (isAdmin && isAdminMoveAllowed || (isPC && loggedInCharId === selectedCharacterId && gameState === 'PREPARATION')) {
                if (targetChar && canPlaceCharacter(targetChar, x, y)) {
                    await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacterId), { x: x, y: y });
                    if (targetChar.x === null) {
                       await logAction(`✅ ${targetChar.name}이(가) 전장에 합류했습니다.`, "join");
                    } else if (isAdmin) {
                       await logAction(`👮 관리자가 ${targetChar.name}을(를) (${targetChar.x},${targetChar.y})에서 (${x}, ${y})로 이동했습니다.`, "admin-move");
                    }
                    selectedCharacterId = null;
                } else {
                     showCustomModal("배치 오류", "해당 위치는 이미 다른 캐릭터가 차지하고 있거나 장애물입니다.", [{ text: "확인", class: "bg-red-600" }]);
                }
            } else {
                showCustomModal("권한 부족", `${targetChar?.name || '캐릭터'}를 배치하려면 로그인하거나 관리자 권한이 필요합니다.`, [{ text: "확인", class: "bg-red-600" }]);
            }
        } else {
             selectedCharacterId = null;
             render();
        }
    }

    async function handleCombatClick(e) {
        const cell = e.target.closest('.cell');
        if (!cell) return;

        const cellX = parseInt(cell.dataset.x);
        const cellY = parseInt(cell.dataset.y);
        
        // =================================================================
        // 👇 [핵심 수정] 캐릭터를 찾기 전에, 이동 단계인지 먼저 확인합니다.
        // =================================================================
        const clickedChar = characters.find(char => {
            if (char.x === null) return false;

            // 만약 '이동 단계'이고, 지금 찾는 캐릭터가 '선택된 캐릭터'와 같다면,
            // 클릭을 통과시켜야 하므로 '못 찾은 척' 합니다. (return false)
            if (turnPhase === 'MOVE' && selectedCharacterId === char.id) {
                return false;
            }

            const size = char.size || 1;
            const isXMatch = cellX >= char.x && cellX < (char.x + size);
            const isYMatch = cellY >= char.y && cellY < (char.y + size);
            return isXMatch && isYMatch;
        });

        const clickedCharId = clickedChar ? clickedChar.id : null;


        // --- 이 아래의 기존 로직은 모두 동일합니다 ---
        const previouslySelectedCharId = selectedCharacterId;
        const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
        const currentTurnChar = characters[currentTurnIndex];
        const isControllable = selectedCharacter && canControlCharacter(selectedCharacter.id);

        if (e.detail === 2 && clickedChar) {
            openProfileModal(clickedChar);
            return;
        }

        if (clickedCharId && currentTurnChar?.id === clickedCharId && (isAdmin || loggedInCharId === clickedCharId)) {
            selectedCharacterId = clickedCharId;

            if (turnPhase === 'MOVE') {
                const isClickOnMarker = e.target.closest('.turn-marker');
                const isClickOnSelfCell = cellX >= clickedChar.x && cellX < (clickedChar.x + (clickedChar.size || 1)) &&
                                        cellY >= clickedChar.y && cellY < (clickedChar.y + (clickedChar.size || 1));

                if (isClickOnMarker || (isClickOnSelfCell && previouslySelectedCharId === clickedCharId)) {
                    turnPhase = 'ACTION';
                    selectedSkill = null;
                    preMovePosition = { x: clickedChar.x, y: clickedChar.y };
                    logAction(`⏩ ${clickedChar.name}이(가) 제자리 이동으로 단계를 건너뛰었습니다.`, "system");
                    render();
                    return;
                }
            }

            turnPhase = 'MOVE';
            selectedSkill = 'move';
            preMovePosition = { x: clickedChar.x, y: clickedChar.y };
            render();
            return;
        }

        if (!isControllable) {
            selectedCharacterId = null;
            selectedSkill = null;
            render();
            return;
        }

        if (turnPhase === 'MOVE') {
            if (selectedCharacter.statusEffects && selectedCharacter.statusEffects.some(e => e.id === 'rooted')) {
                const rootedEffect = selectedCharacter.statusEffects.find(e => e.id === 'rooted');
                showCustomModal("이동 불가", `[${rootedEffect.name}] 효과를 받아 움직일 수 없습니다.`, [{ text: "확인", class: "bg-red-600" }]);
                return;
            }

            const newX = parseInt(cell.dataset.x), newY = parseInt(cell.dataset.y);
            const tileType = boardTiles[`${newX},${newY}`]?.type;

            if (tileType === 'obstacle' && !isAdmin) {
                showCustomModal("이동 불가", "이 칸은 장애물입니다. 이동할 수 없습니다.", [{ text: "확인", class: "bg-red-600" }]);
                return;
            }
            
            if (cell.classList.contains('attack-range-move')) {
                const isZeroMove = selectedCharacter.x === newX && selectedCharacter.y === newY;
                await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), { x: newX, y: newY });
                
                if (isZeroMove) {
                    logAction(`⏩ ${selectedCharacter.name}이(가) 제자리 이동했습니다.`, "move");
                } else if (isAdmin) {
                    await logAction(`👮 관리자가 ${selectedCharacter.name}을(를) (${selectedCharacter.x},${selectedCharacter.y})에서 (${newX}, ${newY})로 이동했습니다.`, "admin-move");
                } else {
                    await logAction(`🏃 ${selectedCharacter.name}이(가) (${newX}, ${newY})(으)로 이동했습니다.`, "move");
                }
                
                turnPhase = 'ACTION'; 
                selectedSkill = null;
                render();
            }
        } else if (turnPhase === 'ACTION') {
            const skill = SKILLS[selectedSkill];
            if (!skill) {
                showCustomModal("행동 필요", "사용할 스킬을 선택해 주세요.", [{ text: "확인", class: "bg-yellow-600" }]);
                return;
            }

            const isAttackSkill = skill.category === 'Attack';
            const isHealOrSupport = skill.category === 'Heal' || skill.category === 'Support';
            
            if (isAttackSkill) {
                if (selectedCharacter.mp < skill.mpCost) {
                    await logAction(`⚠️ ${selectedCharacter.name}이(가) 마나가 부족하여 ${skill.name}을(를) 시전하지 못했습니다.`, "system");
                    render();
                    return;
                }
                
                if (skill.isAoe) {
                    if (cell.classList.contains('attack-range-skill')) {
                        await executeSkill(selectedCharacter, { x: parseInt(cell.dataset.x), y: parseInt(cell.dataset.y) }, selectedSkill);
                    }
                } else if (clickedChar) {
                    const targetChar = clickedChar;
                    if (selectedCharacter.type !== targetChar.type && cell.classList.contains('attack-range-skill')) {
                        await executeSkill(selectedCharacter, targetChar, selectedSkill);
                    }
                }
            } else if (isHealOrSupport) {
                if (selectedCharacter.mp < skill.mpCost || (skill.hpCost && selectedCharacter.hp <= skill.hpCost)) {
                    await logAction(`⚠️ ${selectedCharacter.name}이(가) 자원(MP/HP)이 부족하여 ${skill.name}을(를) 시전하지 못했습니다.`, "system");
                    render();
                    return;
                }
                
                if (skill.isAoe) {
                    if (cell.classList.contains('heal-range-skill')) {
                        await executeSkill(selectedCharacter, { x: parseInt(cell.dataset.x), y: parseInt(cell.dataset.y) }, selectedSkill);
                    }
                } else if (clickedChar) {
                    const targetChar = clickedChar;
                    
                    let isValidTarget = false;
                    if (skill.targetType === 'ALLY_DEAD') {
                        if (selectedCharacter.type === targetChar.type && targetChar.hp <= 0 && cell.classList.contains('heal-range-skill')) {
                            isValidTarget = true;
                        }
                    } else if (skill.targetType === 'ALLY') {
                        if (selectedCharacter.type === targetChar.type && targetChar.hp > 0 && cell.classList.contains('heal-range-skill')) {
                            isValidTarget = true;
                        }
                    }
                    
                    if (isValidTarget) {
                        await executeSkill(selectedCharacter, targetChar, selectedSkill);
                    }
                }
            }
        }
    } 

    async function gameBoardClick(e) {
        if(!gameId) return;
        if (gameState === 'PREPARATION') {
            await handlePreparationClick(e);
        } else if (gameState === 'STARTED') {
            await handleCombatClick(e);
        }
    }
    
    // --- Map Edit Modal Listeners ---
    document.querySelectorAll('.tile-select-btn').forEach(btn => {
        btn.onclick = (e) => {
            currentTileType = e.currentTarget.dataset.tileType;
            document.getElementById('map-edit-status').textContent = `현재 선택: ${e.currentTarget.textContent.trim()}`;
        };
    });

    // "맵 편집 종료" 버튼만 isMapEditMode를 false로 설정합니다.
    document.getElementById('exit-map-edit-btn').onclick = confirmExitMapEditMode;
    
    // 'X' 버튼과 배경 클릭은 팝업만 닫고 isMapEditMode는 유지합니다.
    document.getElementById('close-map-edit-modal-btn').onclick = hideMapEditModalTemporarily; 
    mapEditModal.addEventListener('click', e => { 
        // Close only if the backdrop itself (map-edit-modal) is clicked
        if (e.target.id === 'map-edit-modal') hideMapEditModalTemporarily(); 
    });
    // --- End Map Edit Modal Listeners ---


    createGameBtn.addEventListener('click', createGame);
    joinGameBtn.addEventListener('click', () => joinGame(gameIdInput.value));
    leaveGameBtn.addEventListener('click', leaveGame);
    
    // User Info Modal Handlers
    userInfoBtn.addEventListener('click', () => { userInfoModal.classList.remove('hidden'); });
    // Fix: Use the dedicated button ID to close the User Info Modal
    document.getElementById('close-user-info-modal-btn').onclick = () => closeModal('user-info-modal');
    userInfoModal.addEventListener('click', (e) => { 
        // Only close if backdrop is clicked
        if (e.target.id === 'user-info-modal') closeModal('user-info-modal'); 
    });
    
    // Copy button inside User Info Modal
    document.getElementById('user-info-copy-btn').addEventListener('click', () => { 
        const input = document.getElementById('user-info-game-id-display');
        input.select(); 
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(input.value).then(() => {
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Modern API)", [{ text: "확인", class: "bg-green-600" }]);
            }).catch(err => {
                document.execCommand('copy');
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Fallback)", [{ text: "확인", class: "bg-green-600" }]);
                console.error('Async clipboard copy failed:', err);
            });
        } else {
             document.execCommand('copy');
             showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다.", [{ text: "확인", class: "bg-green-600" }]);
        }
    });

    // Original Game ID container copy logic (still needed if the original container is shown in the lobby phase)
    copyGameIdBtn.addEventListener('click', () => { 
        const input = document.getElementById('game-id-display');
        input.select(); 
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(input.value).then(() => {
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Modern API)", [{ text: "확인", class: "bg-green-600" }]);
            }).catch(err => {
                document.execCommand('copy');
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Fallback)", [{ text: "확인", class: "bg-green-600" }]);
                console.error('Async clipboard copy failed:', err);
            });
        } else {
             document.execCommand('copy');
             showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다.", [{ text: "확인", class: "bg-green-600" }]);
        }
    });
    
    document.getElementById('overlay-toggle').addEventListener('click', (e) => {
         const overlay = document.getElementById('character-selection-overlay');
         overlay.classList.toggle('collapsed');
         e.currentTarget.querySelector('svg').style.transform = overlay.classList.contains('collapsed') ? 'rotate(180deg)' : 'rotate(0deg)';
    });
    profileModal.addEventListener('click', e => { if (e.target.id === 'profile-modal') closeModal('profile-modal'); });
    
    document.getElementById('submit-char-login-btn').addEventListener('click', handlePCLogin);
    document.getElementById('cancel-char-login-btn').addEventListener('click', () => closeModal('pc-login-modal'));
    // Re-route original login/logout button handlers
    // document.getElementById('login-btn').addEventListener('click', openPCLoginModal); // Removed, now handled by User Info Modal
    // document.getElementById('logout-btn').addEventListener('click', handleLogout); // Removed, now handled by User Info Modal
    pcLoginModal.addEventListener('click', e => { if (e.target.id === 'pc-login-modal') closeModal('pc-login-modal'); });
    
    document.getElementById('admin-panel-btn').addEventListener('click', () => { 
        if (isAdmin) {
            openAdminModal();
        } else {
            adminPasswordModal.classList.remove('hidden'); document.getElementById('admin-password-input').focus();
        }
    });
    document.getElementById('cancel-admin-login-btn').addEventListener('click', () => closeModal('admin-password-modal'));
    
    document.getElementById('submit-admin-login-btn').addEventListener('click', async () => {
        const input = document.getElementById('admin-password-input');
        const errorP = document.getElementById('admin-password-error');
        if (gameId) {
            const gameDoc = await getDoc(doc(db, 'games', gameId));
            const correctPassword = gameDoc.data().adminPassword || "0000";
            if (input.value === correctPassword) {
                closeModal('admin-password-modal');
                isAdmin = true;
                loggedInCharId = null;
                openAdminModal();
                input.value = '';
                errorP.textContent = '';
                updateAuthStatus();
                await logAction("👑 관리자가 로그인했습니다.", "system");
            } else {
                errorP.textContent = '비밀번호가 올바르지 않습니다.';
                input.value = '';
            }
        }
    });

    gameBoard.addEventListener('click', gameBoardClick);
    gameBoard.addEventListener('dragover', e => e.preventDefault());
    gameBoard.addEventListener('drop', async e => {
        e.preventDefault(); if(!gameId) return;
        const charId = e.dataTransfer.getData('text/plain'), cell = e.target.closest('.cell');
        if (cell && charId) {
            const targetChar = characters.find(c => c.id === charId);
            const isPC = targetChar?.type === 'PC';

            const canDragAndDrop = (isAdmin && isAdminMoveAllowed) || (isPC && loggedInCharId === charId);

            if (targetChar && canDragAndDrop && (gameState === 'PREPARATION' || targetChar.x === null || isAdminMoveAllowed)) {
                const newX = parseInt(cell.dataset.x);
                const newY = parseInt(cell.dataset.y);

                if (canPlaceCharacter(targetChar, newX, newY)) {
                    await updateDoc(doc(db, 'games', gameId, 'characters', charId), { x: newX, y: newY });
                    
                     if (targetChar.x === null) {
                       await logAction(`✅ ${targetChar.name}이(가) 전장에 합류했습니다.`, "join");
                    } else if (isAdmin) {
                       await logAction(`👮 관리자가 ${targetChar.name}을(를) (${targetChar.x},${targetChar.y})에서 (${newX}, ${newY})로 이동했습니다.`, "admin-move");
                    }
                } else {
                     showCustomModal("배치 오류", "해당 위치는 이미 다른 캐릭터가 차지하고 있거나 장애물입니다.", [{ text: "확인", class: "bg-red-600" }]);
                }
            } else if (targetChar && targetChar.x !== null && gameState === 'STARTED') {
                showCustomModal("권한 부족", "전투 중에는 관리자만 토큰을 자유롭게 이동할 수 있습니다. (관리자 이동 권한이 해제되었을 수도 있습니다)", [{ text: "확인", class: "bg-red-600" }]);
            }
        }
    });
 async function saveSettingsToFile() {
        if (!gameId) return;

        // 1. 저장할 모든 데이터를 하나의 객체로 모읍니다.
        const settingsToSave = {
            gameSettings: {
                skills: SKILLS,
                maxRounds: maxRounds,
                boardBackgroundImage: boardBackgroundImage,
                pageBackgroundImage: pageBackgroundImage,
                isAdminMoveAllowed: isAdminMoveAllowed
            },
            boardTiles: boardTiles,
            characters: characters.map(({ id, ...char }) => char) // id는 Firestore에서 자동 생성되므로 제외
        };

        // 2. 객체를 JSON 문자열로 변환합니다.
        const jsonString = JSON.stringify(settingsToSave, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        // 3. 가상의 링크를 만들어 다운로드를 실행합니다.
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
        a.download = `game-settings-${gameId}-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        await logAction("💾 관리자가 현재 게임 설정을 파일로 저장했습니다.", "admin");
    }

    // 👇 [새로 추가] 파일에서 설정을 불러와 게임에 적용하는 함수
    async function loadSettingsFromFile(file) {
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const settings = JSON.parse(e.target.result);

                // 파일 유효성 검사
                if (!settings.gameSettings || !settings.boardTiles || !settings.characters) {
                    throw new Error("올바르지 않은 설정 파일 형식입니다.");
                }

                showCustomModal("설정 불러오기 확인", "정말로 파일에서 설정을 불러오시겠습니까? 현재 게임의 모든 캐릭터, 스킬, 맵 설정이 파일의 내용으로 **완전히 교체**됩니다. 이 작업은 되돌릴 수 없습니다.", [
                    { text: "취소", class: "bg-gray-600" },
                    { text: "확인 (덮어쓰기)", class: "bg-red-600", onClick: async () => {
                        
                        // 1. 기존 캐릭터 데이터를 모두 삭제합니다.
                        const charCollectionRef = collection(db, "games", gameId, "characters");
                        const snapshot = await getDocs(charCollectionRef);
                        const deleteBatch = writeBatch(db);
                        snapshot.docs.forEach(doc => deleteBatch.delete(doc.ref));
                        await deleteBatch.commit();

                        // 2. 파일에서 읽어온 새 캐릭터 데이터를 추가합니다.
                        const addBatch = writeBatch(db);
                        settings.characters.forEach(charData => {
                            const newCharRef = doc(collection(db, "games", gameId, "characters"));
                            addBatch.set(newCharRef, charData);
                        });
                        await addBatch.commit();

                        // 3. 나머지 게임 설정을 업데이트합니다.
                        const gameDocRef = doc(db, 'games', gameId);
                        await updateDoc(gameDocRef, settings.gameSettings);

                        // 4. 맵 타일 정보를 업데이트합니다.
                        const boardDocRef = doc(db, 'games', gameId, 'board', 'tiles');
                        await setDoc(boardDocRef, { tiles: settings.boardTiles });

                        await logAction("📂 관리자가 파일에서 게임 설정을 불러왔습니다. 모든 데이터가 교체되었습니다.", "admin");
                        showCustomModal("성공", "설정을 성공적으로 불러왔습니다. 페이지가 새로고침됩니다.", [{text: "확인", class: "bg-green-600", onClick: () => location.reload()}]);
                    }}
                ]);

            } catch (error) {
                console.error("설정 파일 불러오기 실패:", error);
                showCustomModal("오류", "설정 파일을 읽는 중 오류가 발생했습니다. 파일이 손상되었거나 형식이 올바르지 않습니다.", [{text: "확인", class: "bg-red-600"}]);
            }
        };
        reader.readAsText(file);
    }

    adminModal.addEventListener('click', e => {
        // 클릭된 대상(e.target)이 모달의 배경(id: admin-modal) 자체일 때만 닫습니다.
        if (e.target.id === 'admin-modal') {
            closeModal('admin-modal');
        }
    });
    
    const applyTheme = (theme) => {
        document.documentElement.classList.toggle('light', theme === 'light');
        // Re-render to ensure scrollbars update correctly on theme change (due to CSS variable change)
        render(); 
    }
    document.getElementById('theme-toggle-btn').addEventListener('click', () => {
        const newTheme = document.documentElement.classList.contains('light') ? 'dark' : 'light';
        localStorage.setItem('theme', newTheme);
        applyTheme(newTheme);
    });
    applyTheme(localStorage.getItem('theme') || 'dark');
</script>
</body>
</html>
